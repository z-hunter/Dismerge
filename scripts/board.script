-- Подключаем модуль эволюционных таблиц
local evolution_tables = require("scripts.evolution_tables")
-- Подключаем модуль конфигурации поля
local field_config = require("scripts.field_config")
-- Подключаем модуль конфигурации генераторов
local generator_config = require("scripts.generator_config")
-- Подключаем утилиты
local utils = require("scripts.utils")

local CELL_SIZE = 64
local GRID_WIDTH = 7
local GRID_HEIGHT = 9

-- ручной сдвиг (в пикселях)
local FIX_X = 300
local FIX_Y = 300

-- получить позицию ячейки по координатам сетки
local function grid_to_screen(gx, gy)
	local half_width = (GRID_WIDTH - 1) * CELL_SIZE / 2
	local half_height = (GRID_HEIGHT - 1) * CELL_SIZE / 2
	return vmath.vector3(
		(gx - 1) * CELL_SIZE - half_width + FIX_X,
		(gy - 1) * CELL_SIZE - half_height + FIX_Y,
		0
	)
end

-- Найти ячейку по экранным координатам
local function find_cell_at_position(screen_x, screen_y)
	for x = 1, GRID_WIDTH do
		for y = 1, GRID_HEIGHT do
			local cell_pos = grid_to_screen(x, y)
			local distance = vmath.length(vmath.vector3(screen_x, screen_y, 0) - cell_pos)
			if distance <= CELL_SIZE / 2 then
				print("BOARD: Found cell at (" .. x .. ", " .. y .. ") for screen pos (" .. screen_x .. ", " .. screen_y .. ") distance: " .. distance)
				return { x = x, y = y }
			end
		end
	end
	print("BOARD: No cell found for screen pos (" .. screen_x .. ", " .. screen_y .. ")")
	return nil
end

-- Найти все свободные клетки на поле
local function find_empty_cells(self)
	local empty_cells = {}
	for x = 1, GRID_WIDTH do
		for y = 1, GRID_HEIGHT do
			local token_key = utils.get_token_key(x, y)
			if not self.tokens[token_key] then
				table.insert(empty_cells, { x = x, y = y })
			end
		end
	end
	return empty_cells
end

-- Найти ближайшую свободную клетку к заданной позиции
local function find_nearest_empty_cell(self, source_x, source_y)
	local empty_cells = find_empty_cells(self)
	if #empty_cells == 0 then
		return nil -- Нет свободных клеток
	end
	
	local nearest_cell = empty_cells[1]
	local min_distance = math.huge
	
	for _, cell in ipairs(empty_cells) do
		local distance = math.sqrt((cell.x - source_x)^2 + (cell.y - source_y)^2)
		if distance < min_distance then
			min_distance = distance
			nearest_cell = cell
		end
	end
	
	return nearest_cell
end

-- Найти соседние свободные клетки (для ближнего дропа)
local function find_adjacent_empty_cells(self, source_x, source_y)
	local adjacent_cells = {}
	local directions = {
		{-1, -1}, {-1, 0}, {-1, 1},
		{0, -1},           {0, 1},
		{1, -1},  {1, 0},  {1, 1}
	}
	
	for _, dir in ipairs(directions) do
		local x = source_x + dir[1]
		local y = source_y + dir[2]
		
		-- Проверяем границы поля
		if x >= 1 and x <= GRID_WIDTH and y >= 1 and y <= GRID_HEIGHT then
			local token_key = utils.get_token_key(x, y)
			if not self.tokens[token_key] then
				table.insert(adjacent_cells, { x = x, y = y })
			end
		end
	end
	
	return adjacent_cells
end

function init(self)
	msg.post(".", "acquire_input_focus")
	
	-- Инициализируем генератор случайных чисел
	math.randomseed(os.time())

	-- Инициализируем основные структуры данных
	self.tokens = {}
	self.cells = {}
	
	-- НОВАЯ СИСТЕМА: Упрощенное состояние перетаскивания
	self.dragged_token = nil -- ID перетаскиваемой фишки
	self.dragged_from = nil -- {x, y} исходная позиция
	self.dragged_level = nil -- уровень перетаскиваемой фишки
	self.dragged_evo_id = nil -- ID эволюционной цепочки перетаскиваемой фишки
	self.is_dragging = false -- флаг перетаскивания
	
	-- СИСТЕМА ВЫДЕЛЕНИЯ ЯЧЕЕК
	self.selected_cell = nil -- {x, y} выделенная ячейка (может быть только одна)
	self.pre_drag_selection = nil -- {x, y} выделение перед началом перетаскивания
	
	-- СИСТЕМА АНИМАЦИИ ПОЛЕТА ФИШЕК
	self.animating_tokens = {} -- список анимируемых фишек
	
	-- СИСТЕМА ПОТЕНЦИАЛЬНОГО ПЕРЕТАСКИВАНИЯ
	self.potential_drag = nil -- информация о потенциальном перетаскивании

	-- Загружаем эволюционные таблицы
	print("BOARD: Loading evolution tables...")
	if evolution_tables.load_evolution_tables() then
		print("BOARD: Evolution tables loaded successfully")
		-- Выводим отладочную информацию
		evolution_tables.debug_print_chains()
	else
		print("BOARD: ERROR - Failed to load evolution tables")
		return
	end

	-- Загружаем конфигурацию генераторов
	print("BOARD: Loading generator configuration...")
	local generators = generator_config.load_generator_config()
	if not generators then
		print("BOARD: ERROR - Failed to load generator configuration")
		return
	end
	
	-- Валидируем конфигурацию генераторов
	local is_valid, error_msg = generator_config.validate_generator_config(evolution_tables)
	if not is_valid then
		print("BOARD: ERROR - Generator configuration validation failed: " .. error_msg)
		return
	end
	
	-- Выводим отладочную информацию о генераторах
	generator_config.debug_print_config()

	-- Загружаем конфигурацию поля
	print("BOARD: Loading field configuration...")
	local field_config_data = field_config.load_initial_field_config()
	if not field_config_data then
		print("BOARD: ERROR - Failed to load field configuration")
		return
	end
	
	-- Валидируем конфигурацию поля
	local is_valid, error_msg = field_config.validate_field_config(field_config_data, evolution_tables)
	if not is_valid then
		print("BOARD: ERROR - Field configuration validation failed: " .. error_msg)
		return
	end
	
	-- Выводим отладочную информацию о конфигурации
	field_config.debug_print_config(field_config_data)

	-- Создаем ячейки доски
	local half_width = (GRID_WIDTH - 1) * CELL_SIZE / 2
	local half_height = (GRID_HEIGHT - 1) * CELL_SIZE / 2

	for x = 1, GRID_WIDTH do
		self.cells[x] = {}
		for y = 1, GRID_HEIGHT do
			local pos = vmath.vector3(
			(x - 1) * CELL_SIZE - half_width + FIX_X,
			(y - 1) * CELL_SIZE - half_height + FIX_Y,
			0
		)
			local id = factory.create("#cell_factory", pos, nil, { grid_x = x, grid_y = y }, 1)
			self.cells[x][y] = { id = id }
		end
	end
	
	-- Создаем фишки согласно загруженной конфигурации
	
	-- Проходим по конфигурации поля
	for line_num, line in pairs(field_config_data) do
		-- Вычисляем реальную Y координату (инвертируем порядок строк)
		-- В CSV строки идут сверху вниз (1 - верхняя), в игре Y=1 - нижняя
		local real_y = GRID_HEIGHT - line_num + 1
		
		for col_num, token_str in pairs(line) do
			-- Парсим строку токена
			local evo_id, level = utils.parse_token_string(token_str)
			
			-- Если ячейка не пустая, создаем токен
			if evo_id and level then
				-- Проверяем, существует ли такая цепочка и уровень
				local chain = evolution_tables.get_evolution_chain(evo_id)
				if not chain then
					print("BOARD: ERROR - Evolution chain '" .. evo_id .. "' not found in config at grid(" .. col_num .. ", " .. real_y .. ")")
				elseif level > chain.max_grade then
					print("BOARD: ERROR - Level " .. level .. " exceeds max grade " .. chain.max_grade .. " for chain '" .. evo_id .. "' at grid(" .. col_num .. ", " .. real_y .. ")")
				else
					local pos = grid_to_screen(col_num, real_y)
					-- Фишки рисуются поверх ячеек (z = 1)
					pos.z = 1
					
					local properties = { level = level, grid_x = col_num, grid_y = real_y }
					local token_id = factory.create("#token_factory", pos, nil, properties, 1)
					local token_key = utils.get_token_key(col_num, real_y)
					self.tokens[token_key] = { id = token_id, level = level, evo_id = evo_id }
					
					-- Отправляем сообщение для установки evo_id после создания
					msg.post(token_id, "set_evo_id", { evo_id = evo_id })
					
					print("BOARD: Created token " .. evo_id .. " level " .. level .. " at grid(" .. col_num .. ", " .. real_y .. ") id=" .. tostring(token_id))
				end
			end
		end
	end
	
	print("BOARD: Initialization complete")
end



function update(self, dt)
	-- НОВАЯ СИСТЕМА: Простое следование за курсором
	if self.is_dragging and self.dragged_token then
		-- Получаем позицию мыши из последнего события
		if self.last_mouse_pos then
			local target_pos = vmath.vector3(self.last_mouse_pos.x, self.last_mouse_pos.y, 1)
			msg.post(self.dragged_token, "set_position", { position = target_pos })
		end
	end
	
	-- Проверка начала перетаскивания при движении мыши
	if self.potential_drag and self.last_mouse_pos then
		local distance = vmath.length(vmath.vector3(self.last_mouse_pos.x, self.last_mouse_pos.y, 0) - vmath.vector3(self.potential_drag.start_pos.x, self.potential_drag.start_pos.y, 0))
		if distance > 10 then -- Если мышь двигалась больше 10 пикселей
			-- Это было перетаскивание - начинаем его
			start_drag(self, self.potential_drag.token_id, self.potential_drag.grid_x, self.potential_drag.grid_y, self.potential_drag.level, self.potential_drag.evo_id)
			self.potential_drag = nil
		end
	end
	
	-- Обработка анимации полета фишек
	if self.animating_tokens then
		local current_time = os.clock()
		local i = 1
		while i <= #self.animating_tokens do
			local anim = self.animating_tokens[i]
			local elapsed = current_time - anim.start_time
			local progress = elapsed / anim.duration
			
			if progress >= 1.0 then
				-- Анимация завершена - перемещаем фишку на финальную позицию
				msg.post(anim.token_id, "set_position", { position = anim.end_pos })
				table.remove(self.animating_tokens, i)
			else
				-- Обновляем позицию
				local current_pos = anim.start_pos + (anim.end_pos - anim.start_pos) * progress
				msg.post(anim.token_id, "set_position", { position = current_pos })
				i = i + 1
			end
		end
	end
end

function on_message(self, message_id, message, sender)
	if message_id == hash("cell_clicked") then
		-- Проверяем, есть ли фишка в этой ячейке
		local token_key = utils.get_token_key(message.grid_x, message.grid_y)
		local token = self.tokens[token_key]
		
		if token then
			-- Если уже есть выделенная ячейка и это та же ячейка - это повторное выделение
			if self.selected_cell and self.selected_cell.x == message.grid_x and self.selected_cell.y == message.grid_y then
				-- Проверяем, не генератор ли это - если да, то активируем
				local generator_id = utils.create_token_string(token.evo_id, token.level)
				if generator_config.is_generator(generator_id) then
					print("BOARD: Generator activated on second click: " .. generator_id .. " at grid(" .. message.grid_x .. ", " .. message.grid_y .. ")")
					activate_generator(self, generator_id, { x = message.grid_x, y = message.grid_y })
				else
					-- Не генератор - просто снимаем выделение
					clear_cell_selection(self)
				end
			else
				-- Первое выделение ячейки с фишкой
				select_cell(self, message.grid_x, message.grid_y)
			end
		else
			-- Клик на пустую ячейку - снимаем выделение
			clear_cell_selection(self)
		end
	elseif message_id == hash("debug_get_state") then
		-- Отладочное сообщение для получения состояния доски
		print("BOARD: DEBUG - Current state:")
		print("  Selected cell: " .. (self.selected_cell and ("(" .. self.selected_cell.x .. ", " .. self.selected_cell.y .. ")") or "none"))
		print("  Pre-drag selection: " .. (self.pre_drag_selection and ("(" .. self.pre_drag_selection.x .. ", " .. self.pre_drag_selection.y .. ")") or "none"))
		print("  Is dragging: " .. tostring(self.is_dragging))
		print("  Dragged token: " .. tostring(self.dragged_token))
		print("  Tokens count: " .. (function() local count = 0 for _ in pairs(self.tokens) do count = count + 1 end return count end)())
	end
end

function on_input(self, action_id, action)
	if action_id == hash("touch") then
		-- Обновляем позицию мыши при перетаскивании
		if self.is_dragging and self.dragged_token then
			self.last_mouse_pos = { x = action.x, y = action.y }
		end
		
		-- Обновляем позицию мыши всегда для следования за курсором
		self.last_mouse_pos = { x = action.x, y = action.y }
		
		if action.pressed then
			-- Если уже перетаскиваем, игнорируем новое нажатие
			if not self.is_dragging then
				-- Определяем ячейку под курсором
				local clicked_cell = find_cell_at_position(action.x, action.y)
				if clicked_cell then
					-- Проверяем, есть ли фишка в этой ячейке
					local token_key = utils.get_token_key(clicked_cell.x, clicked_cell.y)
					local token = self.tokens[token_key]
					
					if token then
						-- Сохраняем информацию о потенциальном перетаскивании
						self.potential_drag = {
							token_id = token.id,
							grid_x = clicked_cell.x,
							grid_y = clicked_cell.y,
							level = token.level,
							evo_id = token.evo_id,
							start_pos = { x = action.x, y = action.y }
						}
					end
					
					-- Отправляем сообщение о клике на ячейку (для выделения)
					if self.cells[clicked_cell.x] and self.cells[clicked_cell.x][clicked_cell.y] then
						local cell_id = self.cells[clicked_cell.x][clicked_cell.y].id
						print("BOARD: Sending clicked message to cell ID: " .. tostring(cell_id) .. " at (" .. clicked_cell.x .. ", " .. clicked_cell.y .. ")")
						msg.post(cell_id, "clicked", {
							grid_x = clicked_cell.x,
							grid_y = clicked_cell.y
						})
					else
						print("BOARD: ERROR - Cell not found in self.cells at (" .. clicked_cell.x .. ", " .. clicked_cell.y .. ")")
					end
				end
			end
		elseif action.released then
			if self.dragged_token then
				-- Обработка отпускания перетаскиваемой фишки
				handle_token_release(self, action.x, action.y)
			elseif self.potential_drag then
				-- Очищаем потенциальное перетаскивание
				self.potential_drag = nil
			end
		end
	end
end

-- СИСТЕМА ВЫДЕЛЕНИЯ ЯЧЕЕК: Функция выделения ячейки
function select_cell(self, grid_x, grid_y)
	-- Проверяем, есть ли фишка в этой ячейке
	local token_key = utils.get_token_key(grid_x, grid_y)
	local token = self.tokens[token_key]
	
	if token then
		print("BOARD: Selecting cell (" .. grid_x .. ", " .. grid_y .. ") with token " .. token.evo_id .. " level " .. token.level)
		
		-- Снимаем предыдущее выделение
		if self.selected_cell then
			clear_cell_selection(self)
		end
		
		-- Выделяем ячейку с фишкой
		self.selected_cell = { x = grid_x, y = grid_y }
		
		-- Визуально выделяем ячейку (изменяем цвет тайла)
		if self.cells[grid_x] and self.cells[grid_x][grid_y] then
			local cell_id = self.cells[grid_x][grid_y].id
			print("BOARD: Sending set_highlighted(true) to cell ID: " .. tostring(cell_id))
			msg.post(cell_id, "set_highlighted", { highlighted = true })
		else
			print("BOARD: ERROR - Cell not found at (" .. grid_x .. ", " .. grid_y .. ")")
		end
		
		-- Показываем информацию о фишке
		show_token_info(self, token.evo_id, token.level)
	else
		print("BOARD: Cannot select cell (" .. grid_x .. ", " .. grid_y .. ") - no token found")
	end
end

-- СИСТЕМА ВЫДЕЛЕНИЯ ЯЧЕЕК: Функция снятия выделения
function clear_cell_selection(self)
	if self.selected_cell then
		print("BOARD: Clearing selection from cell (" .. self.selected_cell.x .. ", " .. self.selected_cell.y .. ")")
		
		if self.cells[self.selected_cell.x] and self.cells[self.selected_cell.x][self.selected_cell.y] then
			local cell_id = self.cells[self.selected_cell.x][self.selected_cell.y].id
			print("BOARD: Sending set_highlighted(false) to cell ID: " .. tostring(cell_id))
			msg.post(cell_id, "set_highlighted", { highlighted = false })
		end
		
		-- Скрываем информацию о фишке
		hide_token_info(self)
		
		self.selected_cell = nil
	else
		print("BOARD: No selection to clear")
	end
end

-- НОВАЯ СИСТЕМА: Функция начала перетаскивания
function start_drag(self, token_id, grid_x, grid_y, level, evo_id)
	self.dragged_token = token_id
	self.dragged_from = { x = grid_x, y = grid_y }
	self.dragged_level = level
	self.dragged_evo_id = evo_id
	self.is_dragging = true
	
	-- Сохраняем информацию о выделении перед началом перетаскивания
	if self.selected_cell then
		self.pre_drag_selection = { x = self.selected_cell.x, y = self.selected_cell.y }
		print("BOARD: Saved pre-drag selection: (" .. self.pre_drag_selection.x .. ", " .. self.pre_drag_selection.y .. ")")
	else
		self.pre_drag_selection = nil
		print("BOARD: No selection to save before drag")
	end
	
	-- Снимаем выделение при начале перетаскивания (не вызываем select_cell)
	if self.selected_cell then
		clear_cell_selection(self)
	end
	
	-- Удаляем фишку из исходной позиции в данных
	local token_key = utils.get_token_key(grid_x, grid_y)
	self.tokens[token_key] = nil
	
	-- Отправляем сообщение фишке о начале перетаскивания
	msg.post(token_id, "start_drag")
	
	print("BOARD: Drag started - token " .. evo_id .. " level " .. level .. " from (" .. grid_x .. ", " .. grid_y .. ")")
end

-- НОВАЯ СИСТЕМА: Функция обработки отпускания фишки
function handle_token_release(self, mouse_x, mouse_y)
	print("BOARD: Handling token release at (" .. mouse_x .. ", " .. mouse_y .. ")")
	
	-- Находим ячейку под курсором
	local target_cell = find_cell_at_position(mouse_x, mouse_y)
	
	if target_cell then
		local target_key = utils.get_token_key(target_cell.x, target_cell.y)
		local target_token = self.tokens[target_key]
		
		-- Проверяем возможность мерджа (одинаковые уровень и цепочка)
		if target_token and target_token.level == self.dragged_level and target_token.evo_id == self.dragged_evo_id then
			-- МЕРДЖ: Объединяем фишки
			print("BOARD: MERGE - " .. target_token.evo_id .. " level " .. target_token.level .. " + " .. self.dragged_evo_id .. " level " .. self.dragged_level)
			perform_merge(self, target_cell, target_token, target_key)
		elseif not target_token then
			-- ПЕРЕМЕЩЕНИЕ: Перемещаем на пустую ячейку
			print("BOARD: MOVE - to empty cell (" .. target_cell.x .. ", " .. target_cell.y .. ")")
			perform_move(self, target_cell)
		else
			-- ВОЗВРАТ: Возвращаем на исходную позицию
			print("BOARD: RETURN - to original position (" .. self.dragged_from.x .. ", " .. self.dragged_from.y .. ")")
			perform_return(self)
		end
	else
		-- ВОЗВРАТ: Не попали в ячейку
		print("BOARD: RETURN - missed cell, returning to (" .. self.dragged_from.x .. ", " .. self.dragged_from.y .. ")")
		perform_return(self)
	end
	
	-- Очищаем состояние перетаскивания
	clear_drag_state(self)
end

-- Функция активации генератора
function activate_generator(self, generator_id, cell)
	-- Получаем случайную фишку из генератора
	local output_token, error_msg = generator_config.get_random_manual_output(generator_id)
	
	if output_token then
		print("BOARD: Generator " .. generator_id .. " generated: " .. output_token)
		-- Создаем фишку на поле
		drop_token_from_generator(self, output_token, cell)
	else
		print("BOARD: Generator " .. generator_id .. " failed to generate: " .. (error_msg or "unknown error"))
	end
end

-- Функция выброса фишки из генератора
function drop_token_from_generator(self, token_string, generator_cell)
	-- Парсим строку токена
	local evo_id, level = utils.parse_token_string(token_string)
	if not evo_id or not level then
		print("BOARD: ERROR - Invalid token string: " .. token_string)
		return
	end
	
	-- Ищем свободную клетку (обычный дроп - любая свободная клетка)
	local target_cell = find_nearest_empty_cell(self, generator_cell.x, generator_cell.y)
	if not target_cell then
		print("BOARD: No empty cells available for drop")
		return
	end
	
	-- Создаем фишку у генератора (начальная позиция для анимации)
	local start_pos = grid_to_screen(generator_cell.x, generator_cell.y)
	start_pos.z = 1
	local properties = { level = level, grid_x = target_cell.x, grid_y = target_cell.y }
	local token_id = factory.create("#token_factory", start_pos, nil, properties, 1)
	
	-- Сохраняем фишку в данных (уже на целевой позиции)
	local token_key = utils.get_token_key(target_cell.x, target_cell.y)
	self.tokens[token_key] = { id = token_id, level = level, evo_id = evo_id }
	
	-- Отправляем evo_id через сообщение
	msg.post(token_id, "set_evo_id", { evo_id = evo_id })
	
	-- Создаем анимацию полета от генератора к целевой клетке
	create_drop_animation(self, token_id, generator_cell, target_cell)
	
	print("BOARD: Token dropped: " .. token_string .. " at grid(" .. target_cell.x .. ", " .. target_cell.y .. ")")
end

-- Функция создания анимации полета фишки
function create_drop_animation(self, token_id, from_cell, to_cell)
	-- Начальная позиция (у генератора)
	local start_pos = grid_to_screen(from_cell.x, from_cell.y)
	start_pos.z = 1
	
	-- Конечная позиция (целевая клетка)
	local end_pos = grid_to_screen(to_cell.x, to_cell.y)
	end_pos.z = 1
	
	-- Анимация полета
	local duration = 0.17 -- секунды (ускорено в 3 раза)
	local start_time = os.clock()
	
	-- Добавляем в список анимируемых фишек
	table.insert(self.animating_tokens, {
		token_id = token_id,
		start_pos = start_pos,
		end_pos = end_pos,
		start_time = start_time,
		duration = duration
	})
	
	-- Сразу перемещаем фишку на начальную позицию для анимации
	msg.post(token_id, "set_position", { position = start_pos })
end

-- НОВАЯ СИСТЕМА: Функция выполнения мерджа
function perform_merge(self, target_cell, target_token, target_key)
	-- Удаляем старые фишки
	go.delete(target_token.id)
	go.delete(self.dragged_token)
	
	-- Получаем результат слияния из эволюционных таблиц
	local merge_result = evolution_tables.get_merge_result(target_token.evo_id, target_token.level)
	
	if merge_result then
		-- Создаем новую фишку с результатом слияния
		local pos = grid_to_screen(target_cell.x, target_cell.y)
		pos.z = 1
		local new_token_id = factory.create("#token_factory", pos, nil, { 
			level = merge_result.level, 
			grid_x = target_cell.x, 
			grid_y = target_cell.y
		}, 1)
		
		-- Отправляем evo_id через сообщение (так как строки нельзя передавать как свойства)
		msg.post(new_token_id, "set_evo_id", { evo_id = merge_result.evo_id })
		
		-- Обновляем данные
		self.tokens[target_key] = { 
			id = new_token_id, 
			level = merge_result.level, 
			evo_id = merge_result.evo_id 
		}
		
		-- Обновляем визуал новой фишки
		msg.post(new_token_id, "update_level", { level = merge_result.level })
		msg.post(new_token_id, "update_evo_id", { evo_id = merge_result.evo_id })
		
		local item_name = evolution_tables.get_item_name(merge_result.evo_id, merge_result.level)
		print("BOARD: Merge completed - new token " .. merge_result.evo_id .. " level " .. merge_result.level .. " (" .. item_name .. ") at (" .. target_cell.x .. ", " .. target_cell.y .. ")")
		
		-- Если была выделена одна из исходных позиций, выделяем новую фишку
		if self.pre_drag_selection and 
		   (self.pre_drag_selection.x == self.dragged_from.x and self.pre_drag_selection.y == self.dragged_from.y) or
		   (self.pre_drag_selection.x == target_cell.x and self.pre_drag_selection.y == target_cell.y) then
			print("BOARD: Selecting merged token at (" .. target_cell.x .. ", " .. target_cell.y .. ")")
			select_cell(self, target_cell.x, target_cell.y)
		end
		
		-- Проверяем выделение после мерджа
		check_selection_after_drag(self)
	else
		print("BOARD: Merge failed - no evolution result for " .. target_token.evo_id .. " level " .. target_token.level)
	end
end

-- НОВАЯ СИСТЕМА: Функция выполнения перемещения
function perform_move(self, target_cell)
	-- Перемещаем фишку на новую позицию
	local pos = grid_to_screen(target_cell.x, target_cell.y)
	pos.z = 1
	msg.post(self.dragged_token, "move_to", { position = pos, smooth = true })
	
	-- Обновляем данные
	local target_key = utils.get_token_key(target_cell.x, target_cell.y)
	self.tokens[target_key] = { id = self.dragged_token, level = self.dragged_level, evo_id = self.dragged_evo_id }
	
	-- Обновляем координаты фишки
	msg.post(self.dragged_token, "set_grid_position", { grid_x = target_cell.x, grid_y = target_cell.y })
	
	print("BOARD: Move completed - token " .. self.dragged_evo_id .. " level " .. self.dragged_level .. " moved to (" .. target_cell.x .. ", " .. target_cell.y .. ")")
	
	-- Если была выделена исходная позиция, выделяем новую позицию
	if self.pre_drag_selection and 
	   self.pre_drag_selection.x == self.dragged_from.x and 
	   self.pre_drag_selection.y == self.dragged_from.y then
		print("BOARD: Moving selection from (" .. self.dragged_from.x .. ", " .. self.dragged_from.y .. ") to (" .. target_cell.x .. ", " .. target_cell.y .. ")")
		select_cell(self, target_cell.x, target_cell.y)
	end
	
	-- Проверяем выделение после перемещения
	check_selection_after_drag(self)
end

-- НОВАЯ СИСТЕМА: Функция выполнения возврата
function perform_return(self)
	-- Возвращаем фишку на исходную позицию
	local pos = grid_to_screen(self.dragged_from.x, self.dragged_from.y)
	pos.z = 1
	msg.post(self.dragged_token, "move_to", { position = pos, smooth = true })
	
	-- Восстанавливаем данные
	local original_key = utils.get_token_key(self.dragged_from.x, self.dragged_from.y)
	self.tokens[original_key] = { id = self.dragged_token, level = self.dragged_level, evo_id = self.dragged_evo_id }
	
	print("BOARD: Return completed - token " .. self.dragged_evo_id .. " level " .. self.dragged_level .. " returned to (" .. self.dragged_from.x .. ", " .. self.dragged_from.y .. ")")
	
	-- Восстанавливаем выделение если фишка вернулась на то же место
	if self.pre_drag_selection and 
	   self.pre_drag_selection.x == self.dragged_from.x and 
	   self.pre_drag_selection.y == self.dragged_from.y then
		-- Восстанавливаем выделение
		select_cell(self, self.dragged_from.x, self.dragged_from.y)
	end
	
	-- Проверяем выделение после возврата
	check_selection_after_drag(self)
end

-- СИСТЕМА ВЫДЕЛЕНИЯ: Функция проверки выделения после перетаскивания
function check_selection_after_drag(self)
	print("BOARD: Checking selection after drag - current selection: " .. (self.selected_cell and ("(" .. self.selected_cell.x .. ", " .. self.selected_cell.y .. ")") or "none"))
	print("BOARD: Pre-drag selection: " .. (self.pre_drag_selection and ("(" .. self.pre_drag_selection.x .. ", " .. self.pre_drag_selection.y .. ")") or "none"))
	print("BOARD: Dragged from: " .. (self.dragged_from and ("(" .. self.dragged_from.x .. ", " .. self.dragged_from.y .. ")") or "none"))
	
	-- Проверяем, есть ли выделение после перетаскивания
	if self.selected_cell then
		-- Проверяем, есть ли фишка в выделенной ячейке
		local token_key = utils.get_token_key(self.selected_cell.x, self.selected_cell.y)
		local token = self.tokens[token_key]
		
		if not token then
			print("BOARD: Token not found in selected cell - clearing selection")
			-- Фишки больше нет в выделенной ячейке - снимаем выделение
			clear_cell_selection(self)
		else
			print("BOARD: Token found in selected cell - keeping selection")
		end
	elseif self.pre_drag_selection then
		print("BOARD: No current selection, checking pre-drag selection (" .. self.pre_drag_selection.x .. ", " .. self.pre_drag_selection.y .. ")")
		-- Если было выделение до перетаскивания, но сейчас его нет
		-- Проверяем, есть ли фишка в той ячейке, которая была выделена
		local token_key = utils.get_token_key(self.pre_drag_selection.x, self.pre_drag_selection.y)
		local token = self.tokens[token_key]
		
		if token then
			print("BOARD: Restoring selection to pre-drag position")
			-- Восстанавливаем выделение
			select_cell(self, self.pre_drag_selection.x, self.pre_drag_selection.y)
		else
			print("BOARD: No token found at pre-drag position - cannot restore selection")
		end
	else
		print("BOARD: No selection to check")
	end
end

-- НОВАЯ СИСТЕМА: Функция очистки состояния перетаскивания
function clear_drag_state(self)
	-- Останавливаем перетаскивание
	msg.post(self.dragged_token, "stop_drag")
	
	-- Очищаем данные
	self.dragged_token = nil
	self.dragged_from = nil
	self.dragged_level = nil
	self.dragged_evo_id = nil
	self.is_dragging = false
	self.last_mouse_pos = nil
	self.pre_drag_selection = nil -- Очищаем сохраненное выделение
	
	print("BOARD: Drag state cleared")
end

-- Функция для отображения информации о фишке
function show_token_info(self, evo_id, level)
	local chain = evolution_tables.get_evolution_chain(evo_id)
	local item_name = evolution_tables.get_item_name(evo_id, level)
	
	if chain and item_name then
		local info_text = chain.name .. " - Уровень " .. level .. " - " .. item_name
		print("BOARD: INFO: " .. info_text)
		
		-- Отправляем сообщение в UI для отображения информации
		msg.post("main:/ui", "show_token_info", {
			chain_name = chain.name,
			level = level,
			item_name = item_name
		})
	else
		print("BOARD: ERROR: Cannot get info for evo_id='" .. tostring(evo_id) .. "' level=" .. tostring(level))
		if not chain then
			print("BOARD: ERROR: Chain not found for evo_id='" .. tostring(evo_id) .. "'")
		end
		if not item_name then
			print("BOARD: ERROR: Item name not found for evo_id='" .. tostring(evo_id) .. "' level=" .. tostring(level))
		end
	end
end

-- Функция для скрытия информации о фишке
function hide_token_info(self)
	print("INFO: Информация о фишке скрыта")
	
	-- Отправляем сообщение в UI для скрытия информации
	msg.post("main:/ui", "hide_token_info")
end
