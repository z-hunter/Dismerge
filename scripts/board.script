-- Подключаем модуль эволюционных таблиц
local evolution_tables = require("scripts.evolution_tables")

local CELL_SIZE = 64
local GRID_WIDTH = 7
local GRID_HEIGHT = 9

-- ручной сдвиг (в пикселях)
local FIX_X = 300
local FIX_Y = 300

-- Начальная конфигурация фишек на поле
-- Формат: {grid_x, grid_y, level, evo_id}
local INITIAL_TOKENS = {
	{1, 1, 1, "TLS"},
	{2, 1, 1, "TLS"},
	{3, 1, 2, "TLS"},
	{4, 1, 1, "FNS"},
	{5, 1, 3, "FNS"},
	{1, 2, 2, "FNS"},
	{2, 2, 1, "SPR"},
	{3, 2, 1, "SPR"},
	{4, 2, 2, "SPR"},
	{5, 2, 1, "CNS"},
	{1, 3, 1, "CNS"},
	{2, 3, 3, "CNS"},
	{3, 3, 1, "LGH"},
	{4, 3, 1, "LGH"},
	{5, 3, 2, "LGH"},
	{5, 6, 5, "ELC"},
}

-- получить позицию ячейки по координатам сетки
local function grid_to_screen(gx, gy)
	local half_width = (GRID_WIDTH - 1) * CELL_SIZE / 2
	local half_height = (GRID_HEIGHT - 1) * CELL_SIZE / 2
	return vmath.vector3(
		(gx - 1) * CELL_SIZE - half_width + FIX_X,
		(gy - 1) * CELL_SIZE - half_height + FIX_Y,
		0
	)
end

-- Найти ячейку по экранным координатам
local function find_cell_at_position(screen_x, screen_y)
	for x = 1, GRID_WIDTH do
		for y = 1, GRID_HEIGHT do
			local cell_pos = grid_to_screen(x, y)
			local distance = vmath.length(vmath.vector3(screen_x, screen_y, 0) - cell_pos)
			if distance <= CELL_SIZE / 2 then
				return { x = x, y = y }
			end
		end
	end
	return nil
end

function init(self)
	msg.post(".", "acquire_input_focus")

	-- Загружаем эволюционные таблицы
	print("BOARD: Loading evolution tables...")
	if evolution_tables.load_evolution_tables() then
		print("BOARD: Evolution tables loaded successfully")
		-- Выводим отладочную информацию
		evolution_tables.debug_print_chains()
	else
		print("BOARD: ERROR - Failed to load evolution tables")
	end

	-- Создаем ячейки доски
	self.cells = {}
	local half_width = (GRID_WIDTH - 1) * CELL_SIZE / 2
	local half_height = (GRID_HEIGHT - 1) * CELL_SIZE / 2

	for x = 1, GRID_WIDTH do
		self.cells[x] = {}
		for y = 1, GRID_HEIGHT do
			local pos = vmath.vector3(
			(x - 1) * CELL_SIZE - half_width + FIX_X,
			(y - 1) * CELL_SIZE - half_height + FIX_Y,
			0
		)
			local id = factory.create("#cell_factory", pos, nil, { grid_x = x, grid_y = y }, 1)
			self.cells[x][y] = { id = id }
		end
	end
	
	-- Создаем фишки согласно начальной конфигурации
	self.tokens = {}
	for _, token_config in ipairs(INITIAL_TOKENS) do
		local x, y, level, evo_id = token_config[1], token_config[2], token_config[3], token_config[4]
		local pos = grid_to_screen(x, y)
		-- Фишки рисуются поверх ячеек (z = 1)
		pos.z = 1
		
		print("BOARD: Creating token with evo_id='" .. tostring(evo_id) .. "' level=" .. tostring(level) .. " at grid(" .. x .. ", " .. y .. ")")
		
		local properties = { level = level, grid_x = x, grid_y = y }
		print("BOARD: Factory properties: level=" .. tostring(properties.level) .. " grid_x=" .. tostring(properties.grid_x) .. " grid_y=" .. tostring(properties.grid_y))
		
		local token_id = factory.create("#token_factory", pos, nil, properties, 1)
		self.tokens[x .. "_" .. y] = { id = token_id, level = level, evo_id = evo_id }
		
		-- Отправляем сообщение для установки evo_id после создания
		msg.post(token_id, "set_evo_id", { evo_id = evo_id })
		
		print("BOARD: Created token " .. evo_id .. " level " .. level .. " at grid(" .. x .. ", " .. y .. ") id=" .. tostring(token_id))
	end

	-- НОВАЯ СИСТЕМА: Упрощенное состояние перетаскивания
	self.dragged_token = nil -- ID перетаскиваемой фишки
	self.dragged_from = nil -- {x, y} исходная позиция
	self.dragged_level = nil -- уровень перетаскиваемой фишки
	self.dragged_evo_id = nil -- ID эволюционной цепочки перетаскиваемой фишки
	self.is_dragging = false -- флаг перетаскивания
	
	print("BOARD: Initialization complete")
end



function update(self, dt)
	-- НОВАЯ СИСТЕМА: Простое следование за курсором
	if self.is_dragging and self.dragged_token then
		-- Получаем позицию мыши из последнего события
		if self.last_mouse_pos then
			local target_pos = vmath.vector3(self.last_mouse_pos.x, self.last_mouse_pos.y, 1)
			msg.post(self.dragged_token, "set_position", { position = target_pos })
			-- Отладочная информация
			print("BOARD: Moving token to (" .. self.last_mouse_pos.x .. ", " .. self.last_mouse_pos.y .. ")")
		else
			print("BOARD: No mouse position available")
		end
	end
end

function on_message(self, message_id, message, sender)
	if message_id == hash("cell_clicked") then
		print("BOARD: Cell clicked at grid(" .. message.grid_x .. ", " .. message.grid_y .. ")")
		
		-- Проверяем, есть ли фишка в этой ячейке
		local token_key = message.grid_x .. "_" .. message.grid_y
		local token = self.tokens[token_key]
		
		if token then
			print("BOARD: Found token " .. token.evo_id .. " level " .. token.level .. " at grid(" .. message.grid_x .. ", " .. message.grid_y .. ")")
			-- Начинаем перетаскивание фишки
			start_drag(self, token.id, message.grid_x, message.grid_y, token.level, token.evo_id)
		else
			print("BOARD: No token at grid(" .. message.grid_x .. ", " .. message.grid_y .. ")")
		end
	end
end

function on_input(self, action_id, action)
	if action_id == hash("touch") then
		-- Обновляем позицию мыши при перетаскивании
		if self.is_dragging and self.dragged_token then
			self.last_mouse_pos = { x = action.x, y = action.y }
		end
		
		-- Обновляем позицию мыши всегда для следования за курсором
		self.last_mouse_pos = { x = action.x, y = action.y }
		
		if action.pressed then
			-- Если уже перетаскиваем, игнорируем новое нажатие
			if not self.is_dragging then
				-- Определяем ячейку под курсором
				local clicked_cell = find_cell_at_position(action.x, action.y)
				if clicked_cell then
					-- Проверяем, есть ли фишка в этой ячейке
					local token_key = clicked_cell.x .. "_" .. clicked_cell.y
					local token = self.tokens[token_key]
					
					if token then
						print("BOARD: Starting drag of token " .. token.evo_id .. " level " .. token.level .. " at grid(" .. clicked_cell.x .. ", " .. clicked_cell.y .. ")")
						-- Начинаем перетаскивание фишки
						start_drag(self, token.id, clicked_cell.x, clicked_cell.y, token.level, token.evo_id)
					end
				end
			end
		elseif action.released and self.dragged_token then
			-- НОВАЯ СИСТЕМА: Обработка отпускания фишки
			handle_token_release(self, action.x, action.y)
		end
	end
end

-- НОВАЯ СИСТЕМА: Функция начала перетаскивания
function start_drag(self, token_id, grid_x, grid_y, level, evo_id)
	self.dragged_token = token_id
	self.dragged_from = { x = grid_x, y = grid_y }
	self.dragged_level = level
	self.dragged_evo_id = evo_id
	self.is_dragging = true
	
	-- Удаляем фишку из исходной позиции в данных
	local token_key = grid_x .. "_" .. grid_y
	self.tokens[token_key] = nil
	
	-- Отправляем сообщение фишке о начале перетаскивания
	msg.post(token_id, "start_drag")
	
	-- Показываем информацию о фишке
	print("BOARD: Вызываем show_token_info с evo_id=" .. tostring(evo_id) .. " level=" .. tostring(level))
	show_token_info(self, evo_id, level)
	
	print("BOARD: Drag started - token " .. evo_id .. " level " .. level .. " from (" .. grid_x .. ", " .. grid_y .. ")")
end

-- НОВАЯ СИСТЕМА: Функция обработки отпускания фишки
function handle_token_release(self, mouse_x, mouse_y)
	print("BOARD: Handling token release at (" .. mouse_x .. ", " .. mouse_y .. ")")
	
	-- Находим ячейку под курсором
	local target_cell = find_cell_at_position(mouse_x, mouse_y)
	
	if target_cell then
		local target_key = target_cell.x .. "_" .. target_cell.y
		local target_token = self.tokens[target_key]
		
		-- Проверяем возможность мерджа (одинаковые уровень и цепочка)
		if target_token and target_token.level == self.dragged_level and target_token.evo_id == self.dragged_evo_id then
			-- МЕРДЖ: Объединяем фишки
			print("BOARD: MERGE - " .. target_token.evo_id .. " level " .. target_token.level .. " + " .. self.dragged_evo_id .. " level " .. self.dragged_level)
			perform_merge(self, target_cell, target_token, target_key)
		elseif not target_token then
			-- ПЕРЕМЕЩЕНИЕ: Перемещаем на пустую ячейку
			print("BOARD: MOVE - to empty cell (" .. target_cell.x .. ", " .. target_cell.y .. ")")
			perform_move(self, target_cell)
		else
			-- ВОЗВРАТ: Возвращаем на исходную позицию
			print("BOARD: RETURN - to original position (" .. self.dragged_from.x .. ", " .. self.dragged_from.y .. ")")
			perform_return(self)
		end
	else
		-- ВОЗВРАТ: Не попали в ячейку
		print("BOARD: RETURN - missed cell, returning to (" .. self.dragged_from.x .. ", " .. self.dragged_from.y .. ")")
		perform_return(self)
	end
	
	-- Очищаем состояние перетаскивания
	clear_drag_state(self)
end

-- НОВАЯ СИСТЕМА: Функция выполнения мерджа
function perform_merge(self, target_cell, target_token, target_key)
	-- Удаляем старые фишки
	go.delete(target_token.id)
	go.delete(self.dragged_token)
	
	-- Получаем результат слияния из эволюционных таблиц
	local merge_result = evolution_tables.get_merge_result(target_token.evo_id, target_token.level)
	
	if merge_result then
		-- Создаем новую фишку с результатом слияния
		local pos = grid_to_screen(target_cell.x, target_cell.y)
		pos.z = 1
		local new_token_id = factory.create("#token_factory", pos, nil, { 
			level = merge_result.level, 
			grid_x = target_cell.x, 
			grid_y = target_cell.y, 
			evo_id = merge_result.evo_id 
		}, 1)
		
		-- Обновляем данные
		self.tokens[target_key] = { 
			id = new_token_id, 
			level = merge_result.level, 
			evo_id = merge_result.evo_id 
		}
		
		-- Обновляем визуал новой фишки
		msg.post(new_token_id, "update_level", { level = merge_result.level })
		msg.post(new_token_id, "update_evo_id", { evo_id = merge_result.evo_id })
		
		local item_name = evolution_tables.get_item_name(merge_result.evo_id, merge_result.level)
		print("BOARD: Merge completed - new token " .. merge_result.evo_id .. " level " .. merge_result.level .. " (" .. item_name .. ") at (" .. target_cell.x .. ", " .. target_cell.y .. ")")
	else
		print("BOARD: Merge failed - no evolution result for " .. target_token.evo_id .. " level " .. target_token.level)
	end
end

-- НОВАЯ СИСТЕМА: Функция выполнения перемещения
function perform_move(self, target_cell)
	-- Перемещаем фишку на новую позицию
	local pos = grid_to_screen(target_cell.x, target_cell.y)
	pos.z = 1
	msg.post(self.dragged_token, "move_to", { position = pos, smooth = true })
	
	-- Обновляем данные
	local target_key = target_cell.x .. "_" .. target_cell.y
	self.tokens[target_key] = { id = self.dragged_token, level = self.dragged_level, evo_id = self.dragged_evo_id }
	
	-- Обновляем координаты фишки
	msg.post(self.dragged_token, "set_grid_position", { grid_x = target_cell.x, grid_y = target_cell.y })
	
	print("BOARD: Move completed - token " .. self.dragged_evo_id .. " level " .. self.dragged_level .. " moved to (" .. target_cell.x .. ", " .. target_cell.y .. ")")
end

-- НОВАЯ СИСТЕМА: Функция выполнения возврата
function perform_return(self)
	-- Возвращаем фишку на исходную позицию
	local pos = grid_to_screen(self.dragged_from.x, self.dragged_from.y)
	pos.z = 1
	msg.post(self.dragged_token, "move_to", { position = pos, smooth = true })
	
	-- Восстанавливаем данные
	local original_key = self.dragged_from.x .. "_" .. self.dragged_from.y
	self.tokens[original_key] = { id = self.dragged_token, level = self.dragged_level, evo_id = self.dragged_evo_id }
	
	print("BOARD: Return completed - token " .. self.dragged_evo_id .. " level " .. self.dragged_level .. " returned to (" .. self.dragged_from.x .. ", " .. self.dragged_from.y .. ")")
end

-- НОВАЯ СИСТЕМА: Функция очистки состояния перетаскивания
function clear_drag_state(self)
	-- Останавливаем перетаскивание
	msg.post(self.dragged_token, "stop_drag")
	
	-- Очищаем данные
	self.dragged_token = nil
	self.dragged_from = nil
	self.dragged_level = nil
	self.dragged_evo_id = nil
	self.is_dragging = false
	self.last_mouse_pos = nil
	
	-- Скрываем информацию о фишке
	hide_token_info(self)
	
	print("BOARD: Drag state cleared")
end

-- Функция для отображения информации о фишке
function show_token_info(self, evo_id, level)
	print("BOARD: show_token_info вызвана с evo_id=" .. tostring(evo_id) .. " level=" .. tostring(level))
	
	local chain = evolution_tables.get_evolution_chain(evo_id)
	local item_name = evolution_tables.get_item_name(evo_id, level)
	
	print("BOARD: chain=" .. tostring(chain) .. " item_name=" .. tostring(item_name))
	
	if chain and item_name then
		local info_text = chain.name .. " - Уровень " .. level .. " - " .. item_name
		print("BOARD: INFO: " .. info_text)
		
		-- Отправляем сообщение в UI для отображения информации
		print("BOARD: Отправляем сообщение в UI")
		msg.post("main:/ui", "show_token_info", {
			chain_name = chain.name,
			level = level,
			item_name = item_name
		})
	else
		print("BOARD: ERROR: Cannot get info for evo_id='" .. tostring(evo_id) .. "' level=" .. tostring(level))
		if not chain then
			print("BOARD: ERROR: Chain not found for evo_id='" .. tostring(evo_id) .. "'")
		end
		if not item_name then
			print("BOARD: ERROR: Item name not found for evo_id='" .. tostring(evo_id) .. "' level=" .. tostring(level))
		end
	end
end

-- Функция для скрытия информации о фишке
function hide_token_info(self)
	print("INFO: Информация о фишке скрыта")
	
	-- Отправляем сообщение в UI для скрытия информации
	msg.post("main:/ui", "hide_token_info")
end
