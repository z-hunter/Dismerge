-- –ü–æ–¥–∫–ª—é—á–∞–µ–º –º–æ–¥—É–ª—å —ç–≤–æ–ª—é—Ü–∏–æ–Ω–Ω—ã—Ö —Ç–∞–±–ª–∏—Ü
local evolution_tables = require("scripts.evolution_tables")
-- –ü–æ–¥–∫–ª—é—á–∞–µ–º –º–æ–¥—É–ª—å –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏ –ø–æ–ª—è
local field_config = require("scripts.field_config")
-- –ü–æ–¥–∫–ª—é—á–∞–µ–º –º–æ–¥—É–ª—å –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏ –≥–µ–Ω–µ—Ä–∞—Ç–æ—Ä–æ–≤
local generator_config = require("scripts.generator_config")
-- –ü–æ–¥–∫–ª—é—á–∞–µ–º –º–æ–¥—É–ª—å –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä–æ–≤ –ø—Ä–æ–≥—Ä–µ—Å—Å–∞
local Indicator = require("scripts.progress_indicator_module")
-- –ü–æ–¥–∫–ª—é—á–∞–µ–º –º–æ–¥—É–ª—å –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è
local debug_logger = require("scripts.debug_logger")
-- –ü–æ–¥–∫–ª—é—á–∞–µ–º —É—Ç–∏–ª–∏—Ç—ã
local utils = require("scripts.utils")

local CELL_SIZE = 64
local GRID_WIDTH = 7
local GRID_HEIGHT = 9

-- —Ä—É—á–Ω–æ–π —Å–¥–≤–∏–≥ (–≤ –ø–∏–∫—Å–µ–ª—è—Ö)
local FIX_X = 300
local FIX_Y = 300

-- –ø–æ–ª—É—á–∏—Ç—å –ø–æ–∑–∏—Ü–∏—é —è—á–µ–π–∫–∏ –ø–æ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∞–º —Å–µ—Ç–∫–∏
local function grid_to_screen(gx, gy)
	local half_width = (GRID_WIDTH - 1) * CELL_SIZE / 2
	local half_height = (GRID_HEIGHT - 1) * CELL_SIZE / 2
	return vmath.vector3(
		(gx - 1) * CELL_SIZE - half_width + FIX_X,
		(gy - 1) * CELL_SIZE - half_height + FIX_Y,
		-0.5
	)
end

-- –ù–∞–π—Ç–∏ —è—á–µ–π–∫—É –ø–æ —ç–∫—Ä–∞–Ω–Ω—ã–º –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∞–º
local function find_cell_at_position(screen_x, screen_y)
	for x = 1, GRID_WIDTH do
		for y = 1, GRID_HEIGHT do
			local cell_pos = grid_to_screen(x, y)
			local distance = vmath.length(vmath.vector3(screen_x, screen_y, 0) - cell_pos)
			if distance <= CELL_SIZE / 2 then
				print("BOARD: Found cell at (" .. x .. ", " .. y .. ") for screen pos (" .. screen_x .. ", " .. screen_y .. ") distance: " .. distance)
				return { x = x, y = y }
			end
		end
	end
	print("BOARD: No cell found for screen pos (" .. screen_x .. ", " .. screen_y .. ")")
	return nil
end

-- –ù–∞–π—Ç–∏ –≤—Å–µ —Å–≤–æ–±–æ–¥–Ω—ã–µ –∫–ª–µ—Ç–∫–∏ –Ω–∞ –ø–æ–ª–µ
local function find_empty_cells(self)
	local empty_cells = {}
	for x = 1, GRID_WIDTH do
		for y = 1, GRID_HEIGHT do
			local token_key = utils.get_token_key(x, y)
			if not self.tokens[token_key] then
				table.insert(empty_cells, { x = x, y = y })
			end
		end
	end
	return empty_cells
end

-- –ù–∞–π—Ç–∏ –±–ª–∏–∂–∞–π—à—É—é —Å–≤–æ–±–æ–¥–Ω—É—é –∫–ª–µ—Ç–∫—É –∫ –∑–∞–¥–∞–Ω–Ω–æ–π –ø–æ–∑–∏—Ü–∏–∏
local function find_nearest_empty_cell(self, source_x, source_y)
	local empty_cells = find_empty_cells(self)
	if #empty_cells == 0 then
		return nil -- –ù–µ—Ç —Å–≤–æ–±–æ–¥–Ω—ã—Ö –∫–ª–µ—Ç–æ–∫
	end
	
	local nearest_cell = empty_cells[1]
	local min_distance = math.huge
	
	for _, cell in ipairs(empty_cells) do
		local distance = math.sqrt((cell.x - source_x)^2 + (cell.y - source_y)^2)
		if distance < min_distance then
			min_distance = distance
			nearest_cell = cell
		end
	end
	
	return nearest_cell
end

-- –ù–∞–π—Ç–∏ —Å–æ—Å–µ–¥–Ω–∏–µ —Å–≤–æ–±–æ–¥–Ω—ã–µ –∫–ª–µ—Ç–∫–∏ (–¥–ª—è –±–ª–∏–∂–Ω–µ–≥–æ –¥—Ä–æ–ø–∞)
local function find_adjacent_empty_cells(self, source_x, source_y)
	local adjacent_cells = {}
	local directions = {
		{-1, -1}, {-1, 0}, {-1, 1},
		{0, -1},           {0, 1},
		{1, -1},  {1, 0},  {1, 1}
	}
	
	for _, dir in ipairs(directions) do
		local x = source_x + dir[1]
		local y = source_y + dir[2]
		
		-- –ü—Ä–æ–≤–µ—Ä—è–µ–º –≥—Ä–∞–Ω–∏—Ü—ã –ø–æ–ª—è
		if x >= 1 and x <= GRID_WIDTH and y >= 1 and y <= GRID_HEIGHT then
			local token_key = utils.get_token_key(x, y)
			if not self.tokens[token_key] then
				table.insert(adjacent_cells, { x = x, y = y })
			end
		end
	end
	
	return adjacent_cells
end

-- üé® –ü—Ä–æ–≤–µ—Ä–∏—Ç—å –Ω–∞–ª–∏—á–∏–µ —Å–ø—Ä–∞–π—Ç–∞ –≤ –æ–±—â–µ–º –∞—Ç–ª–∞—Å–µ evo.atlas
local function check_sprite_availability(evo_id, level)
	local atlas_path = "assets/evo/evo.atlas"
	local sprite_name = evo_id .. "-" .. tostring(level)
	
	local atlas_exists = io.open(atlas_path, "r") ~= nil
	
	if atlas_exists then
		print("BOARD: ‚úÖ –ê—Ç–ª–∞—Å evo.atlas –Ω–∞–π–¥–µ–Ω: " .. atlas_path)
		local atlas_file = io.open(atlas_path, "r")
		if atlas_file then
			local content = atlas_file:read("*all")
			atlas_file:close()
			local image_pattern = "image: \"/assets/evo/" .. sprite_name .. ".png\""
			local sprite_exists = string.find(content, image_pattern, 1, true)
			
			if sprite_exists then
				print("BOARD: ‚úÖ –°–ø—Ä–∞–π—Ç –Ω–∞–π–¥–µ–Ω –≤ evo.atlas: " .. sprite_name)
				return true, "evo", sprite_name -- –í–æ–∑–≤—Ä–∞—â–∞–µ–º "evo" –∫–∞–∫ ID –∞—Ç–ª–∞—Å–∞ –∏ –∏–º—è —Å–ø—Ä–∞–π—Ç–∞
			else
				print("BOARD: ‚ùå –°–ø—Ä–∞–π—Ç –ù–ï –Ω–∞–π–¥–µ–Ω –≤ evo.atlas: " .. sprite_name)
			end
		end
	else
		print("BOARD: ‚ùå –ê—Ç–ª–∞—Å evo.atlas –ù–ï –Ω–∞–π–¥–µ–Ω: " .. atlas_path)
	end
	
	return false, nil, nil -- –í–æ–∑–≤—Ä–∞—â–∞–µ–º false –µ—Å–ª–∏ —Å–ø—Ä–∞–π—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω
end

function init(self)
	msg.post(".", "acquire_input_focus")
	
	-- –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º –≥–µ–Ω–µ—Ä–∞—Ç–æ—Ä —Å–ª—É—á–∞–π–Ω—ã—Ö —á–∏—Å–µ–ª
	math.randomseed(os.time())

	-- –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º –æ—Å–Ω–æ–≤–Ω—ã–µ —Å—Ç—Ä—É–∫—Ç—É—Ä—ã –¥–∞–Ω–Ω—ã—Ö
	self.tokens = {}
	self.cells = {}
	
	-- –ù–û–í–ê–Ø –°–ò–°–¢–ï–ú–ê: –£–ø—Ä–æ—â–µ–Ω–Ω–æ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ –ø–µ—Ä–µ—Ç–∞—Å–∫–∏–≤–∞–Ω–∏—è
	self.dragged_token = nil -- ID –ø–µ—Ä–µ—Ç–∞—Å–∫–∏–≤–∞–µ–º–æ–π —Ñ–∏—à–∫–∏
	self.dragged_from = nil -- {x, y} –∏—Å—Ö–æ–¥–Ω–∞—è –ø–æ–∑–∏—Ü–∏—è
	self.dragged_level = nil -- —É—Ä–æ–≤–µ–Ω—å –ø–µ—Ä–µ—Ç–∞—Å–∫–∏–≤–∞–µ–º–æ–π —Ñ–∏—à–∫–∏
	self.dragged_evo_id = nil -- ID —ç–≤–æ–ª—é—Ü–∏–æ–Ω–Ω–æ–π —Ü–µ–ø–æ—á–∫–∏ –ø–µ—Ä–µ—Ç–∞—Å–∫–∏–≤–∞–µ–º–æ–π —Ñ–∏—à–∫–∏
	self.is_dragging = false -- —Ñ–ª–∞–≥ –ø–µ—Ä–µ—Ç–∞—Å–∫–∏–≤–∞–Ω–∏—è
	
	-- –°–ò–°–¢–ï–ú–ê –í–´–î–ï–õ–ï–ù–ò–Ø –Ø–ß–ï–ï–ö
	self.selected_cell = nil -- {x, y} –≤—ã–¥–µ–ª–µ–Ω–Ω–∞—è —è—á–µ–π–∫–∞ (–º–æ–∂–µ—Ç –±—ã—Ç—å —Ç–æ–ª—å–∫–æ –æ–¥–Ω–∞)
	self.pre_drag_selection = nil -- {x, y} –≤—ã–¥–µ–ª–µ–Ω–∏–µ –ø–µ—Ä–µ–¥ –Ω–∞—á–∞–ª–æ–º –ø–µ—Ä–µ—Ç–∞—Å–∫–∏–≤–∞–Ω–∏—è
	
	-- –°–ò–°–¢–ï–ú–ê –ê–ù–ò–ú–ê–¶–ò–ò –ü–û–õ–ï–¢–ê –§–ò–®–ï–ö
	self.animating_tokens = {} -- —Å–ø–∏—Å–æ–∫ –∞–Ω–∏–º–∏—Ä—É–µ–º—ã—Ö —Ñ–∏—à–µ–∫
	
	-- –°–ò–°–¢–ï–ú–ê –ü–û–¢–ï–ù–¶–ò–ê–õ–¨–ù–û–ì–û –ü–ï–†–ï–¢–ê–°–ö–ò–í–ê–ù–ò–Ø
	self.potential_drag = nil -- –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ –ø–æ—Ç–µ–Ω—Ü–∏–∞–ª—å–Ω–æ–º –ø–µ—Ä–µ—Ç–∞—Å–∫–∏–≤–∞–Ω–∏—è
	
	-- –°–ò–°–¢–ï–ú–ê –ò–ù–î–ò–ö–ê–¢–û–†–û–í –ü–†–û–ì–†–ï–°–°–ê –ì–ï–ù–ï–†–ê–¢–û–†–û–í
	self.generator_indicators = {} -- —Ç–∞–±–ª–∏—Ü–∞ –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä–æ–≤ –ø–æ –∫–ª—é—á—É "x_y"
	self.generator_auto_indicators = {} -- —Ç–∞–±–ª–∏—Ü–∞ –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä–æ–≤ –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏—Ö –≥–µ–Ω–µ—Ä–∞—Ç–æ—Ä–æ–≤ –ø–æ –∫–ª—é—á—É "x_y"
	self.generator_icons = {} -- —Ç–∞–±–ª–∏—Ü–∞ –∏–∫–æ–Ω–æ–∫ –≥–µ–Ω–µ—Ä–∞—Ç–æ—Ä–æ–≤ –ø–æ –∫–ª—é—á—É "x_y"

	-- –ó–∞–≥—Ä—É–∂–∞–µ–º —ç–≤–æ–ª—é—Ü–∏–æ–Ω–Ω—ã–µ —Ç–∞–±–ª–∏—Ü—ã
	print("BOARD: Loading evolution tables...")
	if evolution_tables.load_evolution_tables() then
		print("BOARD: Evolution tables loaded successfully")
		-- –í—ã–≤–æ–¥–∏–º –æ—Ç–ª–∞–¥–æ—á–Ω—É—é –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é
		evolution_tables.debug_print_chains()
	else
		print("BOARD: ERROR - Failed to load evolution tables")
		return
	end

	-- –ó–∞–≥—Ä—É–∂–∞–µ–º –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—é –≥–µ–Ω–µ—Ä–∞—Ç–æ—Ä–æ–≤
	print("BOARD: Loading generator configuration...")
	local generators = generator_config.load_generator_config()
	if not generators then
		print("BOARD: ERROR - Failed to load generator configuration")
		return
	end
	
	-- –í–∞–ª–∏–¥–∏—Ä—É–µ–º –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—é –≥–µ–Ω–µ—Ä–∞—Ç–æ—Ä–æ–≤
	local is_valid, error_msg = generator_config.validate_generator_config(evolution_tables)
	if not is_valid then
		print("BOARD: ERROR - Generator configuration validation failed: " .. error_msg)
		return
	end
	
	-- –í—ã–≤–æ–¥–∏–º –æ—Ç–ª–∞–¥–æ—á–Ω—É—é –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –≥–µ–Ω–µ—Ä–∞—Ç–æ—Ä–∞—Ö
	generator_config.debug_print_config()

	-- –ó–∞–≥—Ä—É–∂–∞–µ–º –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—é –ø–æ–ª—è
	print("BOARD: Loading field configuration...")
	local field_config_data = field_config.load_initial_field_config()
	if not field_config_data then
		print("BOARD: ERROR - Failed to load field configuration")
		return
	end
	
	-- –í–∞–ª–∏–¥–∏—Ä—É–µ–º –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—é –ø–æ–ª—è
	local is_valid, error_msg = field_config.validate_field_config(field_config_data, evolution_tables)
	if not is_valid then
		print("BOARD: ERROR - Field configuration validation failed: " .. error_msg)
		return
	end
	
	-- –í—ã–≤–æ–¥–∏–º –æ—Ç–ª–∞–¥–æ—á–Ω—É—é –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏
	field_config.debug_print_config(field_config_data)

	-- –°–æ–∑–¥–∞–µ–º —è—á–µ–π–∫–∏ –¥–æ—Å–∫–∏
	local half_width = (GRID_WIDTH - 1) * CELL_SIZE / 2
	local half_height = (GRID_HEIGHT - 1) * CELL_SIZE / 2

	for x = 1, GRID_WIDTH do
		self.cells[x] = {}
		for y = 1, GRID_HEIGHT do
			local pos = vmath.vector3(
			(x - 1) * CELL_SIZE - half_width + FIX_X,
			(y - 1) * CELL_SIZE - half_height + FIX_Y,
			-0.5
		)
			local id = factory.create("#cell_factory", pos, nil, { grid_x = x, grid_y = y }, 1)
			self.cells[x][y] = { id = id }
			
			-- –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Å–ª—É—á–∞–π–Ω—ã–π —Ç–∞–π–ª –¥–ª—è —è—á–µ–π–∫–∏ –≤ —à–∞—Ö–º–∞—Ç–Ω–æ–º –ø–æ—Ä—è–¥–∫–µ
			local is_light = (x + y) % 2 == 0
			local tile_variant = math.random(1, 4)
			local tile_name = is_light and ("light_tile_" .. tile_variant) or ("dark_tile_" .. tile_variant)
			msg.post(id, "set_tile", { tile_name = tile_name })
		end
	end
	
	-- –°–æ–∑–¥–∞–µ–º —Ñ–∏—à–∫–∏ —Å–æ–≥–ª–∞—Å–Ω–æ –∑–∞–≥—Ä—É–∂–µ–Ω–Ω–æ–π –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏
	
	-- –ü—Ä–æ—Ö–æ–¥–∏–º –ø–æ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏ –ø–æ–ª—è
	for line_num, line in pairs(field_config_data) do
		-- –í—ã—á–∏—Å–ª—è–µ–º —Ä–µ–∞–ª—å–Ω—É—é Y –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—É (–∏–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º –ø–æ—Ä—è–¥–æ–∫ —Å—Ç—Ä–æ–∫)
		-- –í CSV —Å—Ç—Ä–æ–∫–∏ –∏–¥—É—Ç —Å–≤–µ—Ä—Ö—É –≤–Ω–∏–∑ (1 - –≤–µ—Ä—Ö–Ω—è—è), –≤ –∏–≥—Ä–µ Y=1 - –Ω–∏–∂–Ω—è—è
		local real_y = GRID_HEIGHT - line_num + 1
		
		for col_num, token_str in pairs(line) do
			-- –ü–∞—Ä—Å–∏–º —Å—Ç—Ä–æ–∫—É —Ç–æ–∫–µ–Ω–∞
			local evo_id, level = utils.parse_token_string(token_str)
			
			-- –ï—Å–ª–∏ —è—á–µ–π–∫–∞ –Ω–µ –ø—É—Å—Ç–∞—è, —Å–æ–∑–¥–∞–µ–º —Ç–æ–∫–µ–Ω
			if evo_id and level then
				-- –ü—Ä–æ–≤–µ—Ä—è–µ–º, —Å—É—â–µ—Å—Ç–≤—É–µ—Ç –ª–∏ —Ç–∞–∫–∞—è —Ü–µ–ø–æ—á–∫–∞ –∏ —É—Ä–æ–≤–µ–Ω—å
				local chain = evolution_tables.get_evolution_chain(evo_id)
				if not chain then
					print("BOARD: ERROR - Evolution chain '" .. evo_id .. "' not found in config at grid(" .. col_num .. ", " .. real_y .. ")")
				elseif level > chain.max_grade then
					print("BOARD: ERROR - Level " .. level .. " exceeds max grade " .. chain.max_grade .. " for chain '" .. evo_id .. "' at grid(" .. col_num .. ", " .. real_y .. ")")
				else
					local token_key = create_token_on_board(self, evo_id, level, col_num, real_y)
					print("BOARD: Created token " .. evo_id .. " level " .. level .. " at grid(" .. col_num .. ", " .. real_y .. ") key=" .. tostring(token_key))
				end
			end
		end
	end
	
	print("BOARD: Initialization complete")
	
	-- –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º –≥–µ–Ω–µ—Ä–∞—Ç–æ—Ä—ã –ø–æ—Å–ª–µ —Å–æ–∑–¥–∞–Ω–∏—è –≤—Å–µ—Ö —Ñ–∏—à–µ–∫
	initialize_generators(self)
	
	-- –û–±–Ω–æ–≤–ª—è–µ–º –≤–∏–∑—É–∞–ª –≥–µ–Ω–µ—Ä–∞—Ç–æ—Ä–æ–≤ –ø–æ—Å–ª–µ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏
	-- –í–†–ï–ú–ï–ù–ù–û –û–¢–ö–õ–Æ–ß–ï–ù–û: update_generators_visual(self)
end

function create_token_on_board(self, evo_id, level, grid_x, grid_y, initial_z)
	local pos = grid_to_screen(grid_x, grid_y)
	pos.z = initial_z or 0
	local properties = { level = level, grid_x = grid_x, grid_y = grid_y }
	
	-- üé® –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞–ª–∏—á–∏–µ –∞—Ç–ª–∞—Å–∞ –∏ —Å–ø—Ä–∞–π—Ç–∞ –¥–ª—è —ç—Ç–æ–π —Ñ–∏—à–∫–∏
	local has_sprite, atlas_id, sprite_name = check_sprite_availability(evo_id, level)
	
	local token_id = factory.create("#token_factory", pos, nil, properties, 1)
    
    -- –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ —Ç–æ–∫–µ–Ω –±—ã–ª —Å–æ–∑–¥–∞–Ω —É—Å–ø–µ—à–Ω–æ
    if not token_id then
        print("ERROR: Failed to create token - factory.create returned nil")
        return nil
    end
    
    local token_key = utils.get_token_key(grid_x, grid_y)
    local generator = generator_config.get_generator(utils.create_token_string(evo_id, level))
    if generator and generator.manual then
        self.tokens[token_key] = {
            id = token_id,
            level = level,
            evo_id = evo_id,
            current_capacity = generator.manual.capacity,
            is_reloading = false,
            reload_start_time = 0,
            reload_end_time = 0
        }
        
        -- –°–±—Ä–∞—Å—ã–≤–∞–µ–º —Å—á–µ—Ç—á–∏–∫ —Ü–∏–∫–ª–æ–≤ –¥–ª—è –æ–¥–Ω–æ—Ä–∞–∑–æ–≤—ã—Ö –≥–µ–Ω–µ—Ä–∞—Ç–æ—Ä–æ–≤ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ –Ω–æ–≤–æ–≥–æ —ç–∫–∑–µ–º–ø–ª—è—Ä–∞
        if generator_config.is_disposable(utils.create_token_string(evo_id, level)) then
            generator.manual.completed_cycles = 0
            print("BOARD: Reset completed_cycles for new disposable generator " .. utils.create_token_string(evo_id, level))
        end
    else
        self.tokens[token_key] = { id = token_id, level = level, evo_id = evo_id }
    end
    msg.post(token_id, "set_evo_id", { evo_id = evo_id })
    
    -- üé® –ï—Å–ª–∏ –Ω–∞–π–¥–µ–Ω —Å–ø–µ—Ü–∏–∞–ª—å–Ω—ã–π —Å–ø—Ä–∞–π—Ç, –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ —Ñ–∏—à–∫–µ
    if has_sprite then
        msg.post(token_id, "set_sprite", {
            atlas_id = atlas_id,
            sprite_name = sprite_name
        })
    end
    
    -- –û–±–Ω–æ–≤–ª—è–µ–º –∏–∫–æ–Ω–∫–∏ –≥–µ–Ω–µ—Ä–∞—Ç–æ—Ä–æ–≤ —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ —Å–æ–∑–¥–∞–Ω–Ω—ã–π —Ç–æ–∫–µ–Ω —è–≤–ª—è–µ—Ç—Å—è –≥–µ–Ω–µ—Ä–∞—Ç–æ—Ä–æ–º
    local generator_id = utils.create_token_string(evo_id, level)
    if generator_config.is_generator(generator_id) then
        update_generator_icons(self)
    end
    
    return token_key
end


function update(self, dt)
	-- –ù–û–í–ê–Ø –°–ò–°–¢–ï–ú–ê: –ü—Ä–æ—Å—Ç–æ–µ —Å–ª–µ–¥–æ–≤–∞–Ω–∏–µ –∑–∞ –∫—É—Ä—Å–æ—Ä–æ–º
	if self.is_dragging and self.dragged_token then
		-- –ü–æ–ª—É—á–∞–µ–º –ø–æ–∑–∏—Ü–∏—é –º—ã—à–∏ –∏–∑ –ø–æ—Å–ª–µ–¥–Ω–µ–≥–æ —Å–æ–±—ã—Ç–∏—è
		if self.last_mouse_pos then
			local target_pos = vmath.vector3(self.last_mouse_pos.x, self.last_mouse_pos.y, 0)
			msg.post(self.dragged_token, "set_position", { position = target_pos })
		end
	end
	
	-- –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞—á–∞–ª–∞ –ø–µ—Ä–µ—Ç–∞—Å–∫–∏–≤–∞–Ω–∏—è –ø—Ä–∏ –¥–≤–∏–∂–µ–Ω–∏–∏ –º—ã—à–∏
	if self.potential_drag and self.last_mouse_pos then
		local distance = vmath.length(vmath.vector3(self.last_mouse_pos.x, self.last_mouse_pos.y, 0) - vmath.vector3(self.potential_drag.start_pos.x, self.potential_drag.start_pos.y, 0))
		if distance > 10 then -- –ï—Å–ª–∏ –º—ã—à—å –¥–≤–∏–≥–∞–ª–∞—Å—å –±–æ–ª—å—à–µ 10 –ø–∏–∫—Å–µ–ª–µ–π
			-- –≠—Ç–æ –±—ã–ª–æ –ø–µ—Ä–µ—Ç–∞—Å–∫–∏–≤–∞–Ω–∏–µ - –Ω–∞—á–∏–Ω–∞–µ–º –µ–≥–æ
			start_drag(self, self.potential_drag.token_id, self.potential_drag.grid_x, self.potential_drag.grid_y, self.potential_drag.level, self.potential_drag.evo_id)
			self.potential_drag = nil
		end
	end
	
	-- –û–±—Ä–∞–±–æ—Ç–∫–∞ –∞–Ω–∏–º–∞—Ü–∏–∏ –ø–æ–ª–µ—Ç–∞ —Ñ–∏—à–µ–∫
	if self.animating_tokens then
		local current_time = os.clock()
		local i = 1
		while i <= #self.animating_tokens do
			local anim = self.animating_tokens[i]
			
			-- –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ —Ç–æ–∫–µ–Ω –≤—Å—ë –µ—â—ë —Å—É—â–µ—Å—Ç–≤—É–µ—Ç
			if not go.exists(anim.token_id) then
				print("WARNING: Animating token no longer exists, removing from animation list")
				table.remove(self.animating_tokens, i)
			else
				local elapsed = current_time - anim.start_time
				local progress = elapsed / anim.duration
				
				if progress >= 1.0 then
					-- –ê–Ω–∏–º–∞—Ü–∏—è –∑–∞–≤–µ—Ä—à–µ–Ω–∞ - –ø–µ—Ä–µ–º–µ—â–∞–µ–º —Ñ–∏—à–∫—É –Ω–∞ —Ñ–∏–Ω–∞–ª—å–Ω—É—é –ø–æ–∑–∏—Ü–∏—é
					local end_pos = vmath.vector3(anim.end_pos.x, anim.end_pos.y, 0)
					msg.post(anim.token_id, "set_position", { position = end_pos })
					table.remove(self.animating_tokens, i)
				else
					-- –û–±–Ω–æ–≤–ª—è–µ–º –ø–æ–∑–∏—Ü–∏—é
					local current_pos = anim.start_pos + (anim.end_pos - anim.start_pos) * progress
					current_pos.z = 0
					msg.post(anim.token_id, "set_position", { position = current_pos })
					i = i + 1
				end
			end
		end
	end
	
	-- –û–±—Ä–∞–±–æ—Ç–∫–∞ –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏—Ö –≥–µ–Ω–µ—Ä–∞—Ç–æ—Ä–æ–≤
	update_automatic_generators(self, dt)
	
	-- –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –≤–∏–∑—É–∞–ª–∞ –≥–µ–Ω–µ—Ä–∞—Ç–æ—Ä–æ–≤ (–∏–Ω–¥–∏–∫–∞—Ç–æ—Ä—ã –ø–µ—Ä–µ–∑–∞—Ä—è–¥–∫–∏)
	update_generators_visual(self)
	
	-- –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∞–Ω–∏–º–∞—Ü–∏–∏ –∏–∫–æ–Ω–æ–∫ –≥–µ–Ω–µ—Ä–∞—Ç–æ—Ä–æ–≤
	update_icon_animations(self, dt)
end

-- –§—É–Ω–∫—Ü–∏—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏—Ö –≥–µ–Ω–µ—Ä–∞—Ç–æ—Ä–æ–≤
function update_automatic_generators(self, dt)
	for token_key, token in pairs(self.tokens) do
		local generator_id = utils.create_token_string(token.evo_id, token.level)
		local generator = generator_config.get_generator(generator_id)
		
		if generator and generator.automatic then
			-- –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–µ –ø–µ—Ä–µ—Ç–∞—Å–∫–∏–≤–∞–µ—Ç—Å—è –ª–∏ –≥–µ–Ω–µ—Ä–∞—Ç–æ—Ä
			if not (self.is_dragging and self.dragged_token == token.id) then
				-- –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º —Ç–∞–π–º–µ—Ä—ã –µ—Å–ª–∏ –∏—Ö –Ω–µ—Ç
				if not token.auto_timer then
					token.auto_timer = 0
				end
				if not token.auto_reload_timer then
					token.auto_reload_timer = 0
				end
				if not token.is_auto_reloading then
					token.is_auto_reloading = false
				end
				if not token.auto_capacity then
					token.auto_capacity = generator.automatic.capacity or 0
				end
				
				if token.is_auto_reloading then
					-- –ì–µ–Ω–µ—Ä–∞—Ç–æ—Ä –Ω–∞ –ø–µ—Ä–µ–∑–∞—Ä—è–¥–∫–µ
					token.auto_reload_timer = token.auto_reload_timer + dt
					if token.auto_reload_timer >= (generator.automatic.reload_sec or 0) then
						-- –ü–µ—Ä–µ–∑–∞—Ä—è–¥–∫–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞
						token.is_auto_reloading = false
						token.auto_reload_timer = 0
						token.auto_capacity = generator.automatic.capacity or 0
						print("BOARD: Automatic generator " .. generator_id .. " finished reloading")
					end
				else
					-- –ì–µ–Ω–µ—Ä–∞—Ç–æ—Ä –≥–æ—Ç–æ–≤ –∫ —Ä–∞–±–æ—Ç–µ
					token.auto_timer = token.auto_timer + dt
					if token.auto_timer >= (generator.automatic.timer_sec or 0) then
						-- –í—Ä–µ–º—è –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏
						if token.auto_capacity and token.auto_capacity > 0 then
							-- –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º —Ñ–∏—à–∫—É
							local output_token, error_msg = generator_config.get_random_automatic_output(generator_id)
							if output_token then
								local grid_x, grid_y = utils.parse_token_key(token_key)
								if grid_x and grid_y then
									print("BOARD: Automatic generator " .. generator_id .. " generated: " .. output_token)
									drop_token_from_generator(self, output_token, { x = grid_x, y = grid_y })
									
									-- –£–º–µ–Ω—å—à–∞–µ–º –µ–º–∫–æ—Å—Ç—å
									token.auto_capacity = token.auto_capacity - 1
									
									-- –ï—Å–ª–∏ –µ–º–∫–æ—Å—Ç—å –∑–∞–∫–æ–Ω—á–∏–ª–∞—Å—å, –∑–∞–ø—É—Å–∫–∞–µ–º –ø–µ—Ä–µ–∑–∞—Ä—è–¥–∫—É
									if token.auto_capacity <= 0 and generator.automatic.reload_sec then
										token.is_auto_reloading = true
										token.auto_reload_timer = 0
										print("BOARD: Automatic generator " .. generator_id .. " started reloading")
									end
								end
							else
								print("BOARD: Automatic generator " .. generator_id .. " failed to generate: " .. (error_msg or "unknown error"))
							end
						end
						token.auto_timer = 0
					end
				end
			end
		end
	end
end

-- –§—É–Ω–∫—Ü–∏—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –∞–Ω–∏–º–∞—Ü–∏–∏ –∏–∫–æ–Ω–æ–∫ –≥–µ–Ω–µ—Ä–∞—Ç–æ—Ä–æ–≤
function update_icon_animations(self, dt)
	if not self.icon_animations then
		return
	end
	
	for token_key, animation in pairs(self.icon_animations) do
		local icon_id = self.generator_icons[token_key]
		if icon_id and go.exists(icon_id) then
			-- –û–±–Ω–æ–≤–ª—è–µ–º —Ç–∞–π–º–µ—Ä –∞–Ω–∏–º–∞—Ü–∏–∏
			animation.timer = animation.timer + dt
			
			local phase_progress = 0
			local current_phase_duration = 0
			local current_scale = animation.original_scale
			
			-- –û–ø—Ä–µ–¥–µ–ª—è–µ–º —Ç–µ–∫—É—â—É—é —Ñ–∞–∑—É –∏ –ø—Ä–æ–≥—Ä–µ—Å—Å
			if animation.phase == 0 then
				-- –§–∞–∑–∞ 0: –£–º–µ–Ω—å—à–µ–Ω–∏–µ –¥–æ 0.7
				current_phase_duration = animation.animation_duration
				phase_progress = math.min(animation.timer / current_phase_duration, 1.0)
				current_scale = vmath.lerp(phase_progress, animation.original_scale, vmath.vector3(0.35, 0.35, 1))
				
				if animation.timer >= current_phase_duration then
					animation.phase = 1
					animation.timer = 0
				end
				
			elseif animation.phase == 1 then
				-- –§–∞–∑–∞ 1: –£–≤–µ–ª–∏—á–µ–Ω–∏–µ –¥–æ 1.3
				current_phase_duration = animation.animation_duration
				phase_progress = math.min(animation.timer / current_phase_duration, 1.0)
				current_scale = vmath.lerp(phase_progress, vmath.vector3(0.35, 0.35, 1), vmath.vector3(0.65, 0.65, 1))
				
				if animation.timer >= current_phase_duration then
					animation.phase = 2
					animation.timer = 0
				end
				
			elseif animation.phase == 2 then
				-- –§–∞–∑–∞ 2: –£–º–µ–Ω—å—à–µ–Ω–∏–µ –¥–æ 0.8
				current_phase_duration = animation.animation_duration
				phase_progress = math.min(animation.timer / current_phase_duration, 1.0)
				current_scale = vmath.lerp(phase_progress, vmath.vector3(0.65, 0.65, 1), vmath.vector3(0.4, 0.4, 1))
				
				if animation.timer >= current_phase_duration then
					animation.phase = 3
					animation.timer = 0
				end
				
			elseif animation.phase == 3 then
				-- –§–∞–∑–∞ 3: –í–æ–∑–≤—Ä–∞—Ç –∫ –Ω–æ—Ä–º–∞–ª—å–Ω–æ–º—É —Ä–∞–∑–º–µ—Ä—É
				current_phase_duration = animation.animation_duration
				phase_progress = math.min(animation.timer / current_phase_duration, 1.0)
				current_scale = vmath.lerp(phase_progress, vmath.vector3(0.4, 0.4, 1), animation.original_scale)
				
				if animation.timer >= current_phase_duration then
					animation.phase = 4
					animation.timer = 0
				end
				
			elseif animation.phase == 4 then
				-- –§–∞–∑–∞ 4: –ü–∞—É–∑–∞ 5 —Å–µ–∫—É–Ω–¥
				if animation.timer >= animation.pause_duration then
					animation.phase = 0
					animation.timer = 0
				end
			end
			
			-- –ü—Ä–∏–º–µ–Ω—è–µ–º —Ç–µ–∫—É—â–∏–π —Ä–∞–∑–º–µ—Ä
			go.set_scale(current_scale, icon_id)
		else
			-- –ò–∫–æ–Ω–∫–∞ –±–æ–ª—å—à–µ –Ω–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç, —É–¥–∞–ª—è–µ–º –∞–Ω–∏–º–∞—Ü–∏—é
			self.icon_animations[token_key] = nil
		end
	end
end

function on_message(self, message_id, message, sender)
	if message_id == hash("cell_clicked") then
		-- –ü—Ä–æ–≤–µ—Ä—è–µ–º, –µ—Å—Ç—å –ª–∏ —Ñ–∏—à–∫–∞ –≤ —ç—Ç–æ–π —è—á–µ–π–∫–µ
		local token_key = utils.get_token_key(message.grid_x, message.grid_y)
		local token = self.tokens[token_key]
		
		if token then
			-- –ï—Å–ª–∏ —É–∂–µ –µ—Å—Ç—å –≤—ã–¥–µ–ª–µ–Ω–Ω–∞—è —è—á–µ–π–∫–∞ –∏ —ç—Ç–æ —Ç–∞ –∂–µ —è—á–µ–π–∫–∞ - —ç—Ç–æ –ø–æ–≤—Ç–æ—Ä–Ω–æ–µ –≤—ã–¥–µ–ª–µ–Ω–∏–µ
			if self.selected_cell and self.selected_cell.x == message.grid_x and self.selected_cell.y == message.grid_y then
				-- –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–µ –≥–µ–Ω–µ—Ä–∞—Ç–æ—Ä –ª–∏ —ç—Ç–æ - –µ—Å–ª–∏ –¥–∞, —Ç–æ –∞–∫—Ç–∏–≤–∏—Ä—É–µ–º
				local generator_id = utils.create_token_string(token.evo_id, token.level)
				if generator_config.is_generator(generator_id) then
					print("BOARD: Generator activated on second click: " .. generator_id .. " at grid(" .. message.grid_x .. ", " .. message.grid_y .. ")")
					activate_generator(self, token_key, { x = message.grid_x, y = message.grid_y })
				else
					-- –ù–µ –≥–µ–Ω–µ—Ä–∞—Ç–æ—Ä - –ø—Ä–æ—Å—Ç–æ —Å–Ω–∏–º–∞–µ–º –≤—ã–¥–µ–ª–µ–Ω–∏–µ
					clear_cell_selection(self)
				end
			else
				-- –ü–µ—Ä–≤–æ–µ –≤—ã–¥–µ–ª–µ–Ω–∏–µ —è—á–µ–π–∫–∏ —Å —Ñ–∏—à–∫–æ–π
				select_cell(self, message.grid_x, message.grid_y)
			end
		else
			-- –ö–ª–∏–∫ –Ω–∞ –ø—É—Å—Ç—É—é —è—á–µ–π–∫—É - —Å–Ω–∏–º–∞–µ–º –≤—ã–¥–µ–ª–µ–Ω–∏–µ
			clear_cell_selection(self)
		end
	elseif message_id == hash("debug_get_state") then
		-- –û—Ç–ª–∞–¥–æ—á–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è —Å–æ—Å—Ç–æ—è–Ω–∏—è –¥–æ—Å–∫–∏
		print("BOARD: DEBUG - Current state:")
		print("  Selected cell: " .. (self.selected_cell and ("(" .. self.selected_cell.x .. ", " .. self.selected_cell.y .. ")") or "none"))
		print("  Pre-drag selection: " .. (self.pre_drag_selection and ("(" .. self.pre_drag_selection.x .. ", " .. self.pre_drag_selection.y .. ")") or "none"))
		print("  Is dragging: " .. tostring(self.is_dragging))
		print("  Dragged token: " .. tostring(self.dragged_token))
		print("  Tokens count: " .. (function() local count = 0 for _ in pairs(self.tokens) do count = count + 1 end return count end)())

	end
end

function on_input(self, action_id, action)
	if action_id == hash("touch") then
		-- –û–±–Ω–æ–≤–ª—è–µ–º –ø–æ–∑–∏—Ü–∏—é –º—ã—à–∏ –ø—Ä–∏ –ø–µ—Ä–µ—Ç–∞—Å–∫–∏–≤–∞–Ω–∏–∏
		if self.is_dragging and self.dragged_token then
			self.last_mouse_pos = { x = action.x, y = action.y }
		end
		
		-- –û–±–Ω–æ–≤–ª—è–µ–º –ø–æ–∑–∏—Ü–∏—é –º—ã—à–∏ –≤—Å–µ–≥–¥–∞ –¥–ª—è —Å–ª–µ–¥–æ–≤–∞–Ω–∏—è –∑–∞ –∫—É—Ä—Å–æ—Ä–æ–º
		self.last_mouse_pos = { x = action.x, y = action.y }
		
		if action.pressed then
			-- –ï—Å–ª–∏ —É–∂–µ –ø–µ—Ä–µ—Ç–∞—Å–∫–∏–≤–∞–µ–º, –∏–≥–Ω–æ—Ä–∏—Ä—É–µ–º –Ω–æ–≤–æ–µ –Ω–∞–∂–∞—Ç–∏–µ
			if not self.is_dragging then
				-- –û–ø—Ä–µ–¥–µ–ª—è–µ–º —è—á–µ–π–∫—É –ø–æ–¥ –∫—É—Ä—Å–æ—Ä–æ–º
				local clicked_cell = find_cell_at_position(action.x, action.y)
				if clicked_cell then
					-- –ü—Ä–æ–≤–µ—Ä—è–µ–º, –µ—Å—Ç—å –ª–∏ —Ñ–∏—à–∫–∞ –≤ —ç—Ç–æ–π —è—á–µ–π–∫–µ
					local token_key = utils.get_token_key(clicked_cell.x, clicked_cell.y)
					local token = self.tokens[token_key]
					
					if token then
						-- –°–æ—Ö—Ä–∞–Ω—è–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –ø–æ—Ç–µ–Ω—Ü–∏–∞–ª—å–Ω–æ–º –ø–µ—Ä–µ—Ç–∞—Å–∫–∏–≤–∞–Ω–∏–∏
						self.potential_drag = {
							token_id = token.id,
							grid_x = clicked_cell.x,
							grid_y = clicked_cell.y,
							level = token.level,
							evo_id = token.evo_id,
							start_pos = { x = action.x, y = action.y }
						}
					end
					
					-- –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ –æ –∫–ª–∏–∫–µ –Ω–∞ —è—á–µ–π–∫—É (–¥–ª—è –≤—ã–¥–µ–ª–µ–Ω–∏—è)
					if self.cells[clicked_cell.x] and self.cells[clicked_cell.x][clicked_cell.y] then
						local cell_id = self.cells[clicked_cell.x][clicked_cell.y].id
						print("BOARD: Sending clicked message to cell ID: " .. tostring(cell_id) .. " at (" .. clicked_cell.x .. ", " .. clicked_cell.y .. ")")
						msg.post(cell_id, "clicked", {
							grid_x = clicked_cell.x,
							grid_y = clicked_cell.y
						})
					else
						print("BOARD: ERROR - Cell not found in self.cells at (" .. clicked_cell.x .. ", " .. clicked_cell.y .. ")")
					end
				end
			end
		elseif action.released then
			if self.dragged_token then
				-- –û–±—Ä–∞–±–æ—Ç–∫–∞ –æ—Ç–ø—É—Å–∫–∞–Ω–∏—è –ø–µ—Ä–µ—Ç–∞—Å–∫–∏–≤–∞–µ–º–æ–π —Ñ–∏—à–∫–∏
				handle_token_release(self, action.x, action.y)
			elseif self.potential_drag then
				-- –û—á–∏—â–∞–µ–º –ø–æ—Ç–µ–Ω—Ü–∏–∞–ª—å–Ω–æ–µ –ø–µ—Ä–µ—Ç–∞—Å–∫–∏–≤–∞–Ω–∏–µ
				self.potential_drag = nil
			end
		end
	end
end

-- –°–ò–°–¢–ï–ú–ê –í–´–î–ï–õ–ï–ù–ò–Ø –Ø–ß–ï–ï–ö: –§—É–Ω–∫—Ü–∏—è –≤—ã–¥–µ–ª–µ–Ω–∏—è —è—á–µ–π–∫–∏
function select_cell(self, grid_x, grid_y)
	-- –ü—Ä–æ–≤–µ—Ä—è–µ–º, –µ—Å—Ç—å –ª–∏ —Ñ–∏—à–∫–∞ –≤ —ç—Ç–æ–π —è—á–µ–π–∫–µ
	local token_key = utils.get_token_key(grid_x, grid_y)
	local token = self.tokens[token_key]
	
	if token then
		print("BOARD: Selecting cell (" .. grid_x .. ", " .. grid_y .. ") with token " .. token.evo_id .. " level " .. token.level)
		
		-- –°–Ω–∏–º–∞–µ–º –ø—Ä–µ–¥—ã–¥—É—â–µ–µ –≤—ã–¥–µ–ª–µ–Ω–∏–µ
		if self.selected_cell then
			clear_cell_selection(self)
		end
		
		-- –í—ã–¥–µ–ª—è–µ–º —è—á–µ–π–∫—É —Å —Ñ–∏—à–∫–æ–π
		self.selected_cell = { x = grid_x, y = grid_y }
		
		-- –í–∏–∑—É–∞–ª—å–Ω–æ –≤—ã–¥–µ–ª—è–µ–º —è—á–µ–π–∫—É (–∏–∑–º–µ–Ω—è–µ–º —Ü–≤–µ—Ç —Ç–∞–π–ª–∞)
		if self.cells[grid_x] and self.cells[grid_x][grid_y] then
			local cell_id = self.cells[grid_x][grid_y].id
			print("BOARD: Sending set_highlighted(true) to cell ID: " .. tostring(cell_id))
			msg.post(cell_id, "set_highlighted", { highlighted = true })
		else
			print("BOARD: ERROR - Cell not found at (" .. grid_x .. ", " .. grid_y .. ")")
		end
		
		-- –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ —Ñ–∏—à–∫–µ
		show_token_info(self, token.evo_id, token.level)
	else
		print("BOARD: Cannot select cell (" .. grid_x .. ", " .. grid_y .. ") - no token found")
	end
end

-- –°–ò–°–¢–ï–ú–ê –í–´–î–ï–õ–ï–ù–ò–Ø –Ø–ß–ï–ï–ö: –§—É–Ω–∫—Ü–∏—è —Å–Ω—è—Ç–∏—è –≤—ã–¥–µ–ª–µ–Ω–∏—è
function clear_cell_selection(self)
	if self.selected_cell then
		print("BOARD: Clearing selection from cell (" .. self.selected_cell.x .. ", " .. self.selected_cell.y .. ")")
		
		if self.cells[self.selected_cell.x] and self.cells[self.selected_cell.x][self.selected_cell.y] then
			local cell_id = self.cells[self.selected_cell.x][self.selected_cell.y].id
			print("BOARD: Sending set_highlighted(false) to cell ID: " .. tostring(cell_id))
			msg.post(cell_id, "set_highlighted", { highlighted = false })
		end
		
		-- –°–∫—Ä—ã–≤–∞–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ —Ñ–∏—à–∫–µ
		hide_token_info(self)
		
		self.selected_cell = nil
	else
		print("BOARD: No selection to clear")
	end
end

-- –ù–û–í–ê–Ø –°–ò–°–¢–ï–ú–ê: –§—É–Ω–∫—Ü–∏—è –Ω–∞—á–∞–ª–∞ –ø–µ—Ä–µ—Ç–∞—Å–∫–∏–≤–∞–Ω–∏—è
function start_drag(self, token_id, grid_x, grid_y, level, evo_id)
	self.dragged_token = token_id
	self.dragged_from = { x = grid_x, y = grid_y }
	self.dragged_level = level
	self.dragged_evo_id = evo_id
	self.is_dragging = true
	
	-- –°–æ—Ö—Ä–∞–Ω—è–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –≤—ã–¥–µ–ª–µ–Ω–∏–∏ –ø–µ—Ä–µ–¥ –Ω–∞—á–∞–ª–æ–º –ø–µ—Ä–µ—Ç–∞—Å–∫–∏–≤–∞–Ω–∏—è
	if self.selected_cell then
		self.pre_drag_selection = { x = self.selected_cell.x, y = self.selected_cell.y }
		print("BOARD: Saved pre-drag selection: (" .. self.pre_drag_selection.x .. ", " .. self.pre_drag_selection.y .. ")")
	else
		self.pre_drag_selection = nil
		print("BOARD: No selection to save before drag")
	end
	
	-- –°–Ω–∏–º–∞–µ–º –≤—ã–¥–µ–ª–µ–Ω–∏–µ –ø—Ä–∏ –Ω–∞—á–∞–ª–µ –ø–µ—Ä–µ—Ç–∞—Å–∫–∏–≤–∞–Ω–∏—è (–Ω–µ –≤—ã–∑—ã–≤–∞–µ–º select_cell)
	if self.selected_cell then
		clear_cell_selection(self)
	end
	
	-- –ù–ï —É–¥–∞–ª—è–µ–º —Ñ–∏—à–∫—É –∏–∑ –¥–∞–Ω–Ω—ã—Ö –ø—Ä–∏ –Ω–∞—á–∞–ª–µ –ø–µ—Ä–µ—Ç–∞—Å–∫–∏–≤–∞–Ω–∏—è
	-- –û–Ω–∞ –±—É–¥–µ—Ç –ø–µ—Ä–µ–º–µ—â–µ–Ω–∞ –≤ perform_move –∏–ª–∏ perform_return
	local token_key = utils.get_token_key(grid_x, grid_y)
	print("DEBUG: START_DRAG - token_key=" .. tostring(token_key) .. " for (" .. grid_x .. "," .. grid_y .. ")")
	print("DEBUG: START_DRAG - self.tokens[token_key] exists: " .. tostring(self.tokens[token_key] ~= nil))
	
	-- –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ —Ñ–∏—à–∫–µ –æ –Ω–∞—á–∞–ª–µ –ø–µ—Ä–µ—Ç–∞—Å–∫–∏–≤–∞–Ω–∏—è
	msg.post(token_id, "start_drag")
	
	-- –°–∫—Ä—ã–≤–∞–µ–º –∏–∫–æ–Ω–∫—É –≥–µ–Ω–µ—Ä–∞—Ç–æ—Ä–∞ –ø—Ä–∏ –ø–µ—Ä–µ—Ç–∞—Å–∫–∏–≤–∞–Ω–∏–∏
	hide_generator_icon(self, grid_x, grid_y)
	
	-- –ï—Å–ª–∏ –ø–µ—Ä–µ—Ç–∞—Å–∫–∏–≤–∞–µ–º—ã–π —Ç–æ–∫–µ–Ω —è–≤–ª—è–µ—Ç—Å—è –≥–µ–Ω–µ—Ä–∞—Ç–æ—Ä–æ–º, —É–¥–∞–ª—è–µ–º –µ–≥–æ –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä
	local generator_id = utils.create_token_string(evo_id, level)
	if generator_config.is_generator(generator_id) then
		remove_generator_indicator(self, token_key)
		print("BOARD: Removed indicator for dragged generator " .. generator_id)
	end
	
	print("BOARD: Drag started - token " .. evo_id .. " level " .. level .. " from (" .. grid_x .. ", " .. grid_y .. ")")
end

-- –ù–û–í–ê–Ø –°–ò–°–¢–ï–ú–ê: –§—É–Ω–∫—Ü–∏—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ –æ—Ç–ø—É—Å–∫–∞–Ω–∏—è —Ñ–∏—à–∫–∏
function handle_token_release(self, mouse_x, mouse_y)
	print("BOARD: Handling token release at (" .. mouse_x .. ", " .. mouse_y .. ")")
	
	-- –ù–∞—Ö–æ–¥–∏–º —è—á–µ–π–∫—É –ø–æ–¥ –∫—É—Ä—Å–æ—Ä–æ–º
	local target_cell = find_cell_at_position(mouse_x, mouse_y)
	
	if target_cell then
		local target_key = utils.get_token_key(target_cell.x, target_cell.y)
		local target_token = self.tokens[target_key]
		
		-- –ü—Ä–æ–≤–µ—Ä—è–µ–º –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å –º–µ—Ä–¥–∂–∞ (–æ–¥–∏–Ω–∞–∫–æ–≤—ã–µ —É—Ä–æ–≤–µ–Ω—å –∏ —Ü–µ–ø–æ—á–∫–∞, –Ω–æ –Ω–µ —Å —Å–∞–º–∏–º —Å–æ–±–æ–π)
		if target_token and target_token.level == self.dragged_level and target_token.evo_id == self.dragged_evo_id and 
		   not (target_cell.x == self.dragged_from.x and target_cell.y == self.dragged_from.y) then
			-- –ú–ï–†–î–ñ: –û–±—ä–µ–¥–∏–Ω—è–µ–º —Ñ–∏—à–∫–∏
			print("BOARD: MERGE - " .. target_token.evo_id .. " level " .. target_token.level .. " + " .. self.dragged_evo_id .. " level " .. self.dragged_level)
			perform_merge(self, target_cell, target_token, target_key)
		elseif not target_token then
			-- –ü–ï–†–ï–ú–ï–©–ï–ù–ò–ï: –ü–µ—Ä–µ–º–µ—â–∞–µ–º –Ω–∞ –ø—É—Å—Ç—É—é —è—á–µ–π–∫—É
			print("BOARD: MOVE - to empty cell (" .. target_cell.x .. ", " .. target_cell.y .. ")")
			perform_move(self, target_cell)
		else
			-- –í–û–ó–í–†–ê–¢: –í–æ–∑–≤—Ä–∞—â–∞–µ–º –Ω–∞ –∏—Å—Ö–æ–¥–Ω—É—é –ø–æ–∑–∏—Ü–∏—é
			print("BOARD: RETURN - to original position (" .. self.dragged_from.x .. ", " .. self.dragged_from.y .. ")")
			perform_return(self)
		end
	else
		-- –í–û–ó–í–†–ê–¢: –ù–µ –ø–æ–ø–∞–ª–∏ –≤ —è—á–µ–π–∫—É
		print("BOARD: RETURN - missed cell, returning to (" .. self.dragged_from.x .. ", " .. self.dragged_from.y .. ")")
		perform_return(self)
	end
	
	-- –û—á–∏—â–∞–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ –ø–µ—Ä–µ—Ç–∞—Å–∫–∏–≤–∞–Ω–∏—è
	clear_drag_state(self)
	
	-- –û–±–Ω–æ–≤–ª—è–µ–º –∏–∫–æ–Ω–∫–∏ –≥–µ–Ω–µ—Ä–∞—Ç–æ—Ä–æ–≤ –ø–æ—Å–ª–µ –æ—á–∏—Å—Ç–∫–∏ —Å–æ—Å—Ç–æ—è–Ω–∏—è –ø–µ—Ä–µ—Ç–∞—Å–∫–∏–≤–∞–Ω–∏—è
	update_generator_icons(self)
end

-- –§—É–Ω–∫—Ü–∏—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –≤–∏–∑—É–∞–ª–∞ –≤—Å–µ—Ö –≥–µ–Ω–µ—Ä–∞—Ç–æ—Ä–æ–≤ –Ω–∞ –ø–æ–ª–µ
function update_generators_visual(self)
	for token_key, token in pairs(self.tokens) do
		local generator_id = utils.create_token_string(token.evo_id, token.level)
		
		-- –ü—Ä–æ–≤–µ—Ä—è–µ–º, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ —Ñ–∏—à–∫–∞ –≥–µ–Ω–µ—Ä–∞—Ç–æ—Ä–æ–º
		if generator_config.is_generator(generator_id) then
			local is_reloading = token.is_reloading -- –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ç–æ–ª—å–∫–æ —Ä—É—á–Ω—ã–µ –≥–µ–Ω–µ—Ä–∞—Ç–æ—Ä—ã
			local is_auto_reloading = token.is_auto_reloading -- –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ç–æ–ª—å–∫–æ –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–µ –≥–µ–Ω–µ—Ä–∞—Ç–æ—Ä—ã
			
			-- –û–±–Ω–æ–≤–ª—è–µ–º –≤–∏–∑—É–∞–ª —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –≥–µ–Ω–µ—Ä–∞—Ç–æ—Ä –ø–µ—Ä–µ–∑–∞—Ä—è–∂–∞–µ—Ç—Å—è –∏–ª–∏ –∏–º–µ–µ—Ç –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä
			if is_reloading or is_auto_reloading or self.generator_indicators[token_key] or self.generator_auto_indicators[token_key] then
				update_generator_visual(self, generator_id, token_key, token)
			end
		end
	end
end

-- –§—É–Ω–∫—Ü–∏—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –≤–∏–∑—É–∞–ª–∞ –≥–µ–Ω–µ—Ä–∞—Ç–æ—Ä–∞
function update_generator_visual(self, generator_id, token_key, token)
	local is_reloading = token.is_reloading -- –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ç–æ–ª—å–∫–æ —Ä—É—á–Ω—ã–µ –≥–µ–Ω–µ—Ä–∞—Ç–æ—Ä—ã
	local reload_progress = get_generator_reload_progress(self, token_key)
	local is_auto_reloading = token.is_auto_reloading -- –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ç–æ–ª—å–∫–æ –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–µ –≥–µ–Ω–µ—Ä–∞—Ç–æ—Ä—ã
	local auto_reload_progress = get_generator_auto_reload_progress(self, token_key)
	
	-- –ï—Å–ª–∏ –≥–µ–Ω–µ—Ä–∞—Ç–æ—Ä –ø–µ—Ä–µ—Ç–∞—Å–∫–∏–≤–∞–µ—Ç—Å—è, —É–¥–∞–ª—è–µ–º –≤—Å–µ –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä—ã
	if self.is_dragging and self.dragged_token == token.id then
		remove_generator_indicator(self, token_key)
		remove_generator_auto_indicator(self, token_key)
		return
	end
	
	-- –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º —Ä—É—á–Ω—ã–µ –≥–µ–Ω–µ—Ä–∞—Ç–æ—Ä—ã
	if is_reloading then
		-- –†—É—á–Ω—ã–π –≥–µ–Ω–µ—Ä–∞—Ç–æ—Ä –Ω–∞ –ø–µ—Ä–µ–∑–∞—Ä—è–¥–∫–µ - –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –∏–ª–∏ –æ–±–Ω–æ–≤–ª—è–µ–º –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä
		if self.generator_indicators[token_key] then
			-- –ò–Ω–¥–∏–∫–∞—Ç–æ—Ä —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç - –æ–±–Ω–æ–≤–ª—è–µ–º –ø—Ä–æ–≥—Ä–µ—Å—Å
			self.generator_indicators[token_key]:set_progress(reload_progress)
		else
			-- –°–æ–∑–¥–∞—ë–º –Ω–æ–≤—ã–π –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä –¥–ª—è —Ä—É—á–Ω–æ–≥–æ –≥–µ–Ω–µ—Ä–∞—Ç–æ—Ä–∞
			show_generator_indicator(self, generator_id, token_key, token, reload_progress, "manual")
		end
	else
		-- –†—É—á–Ω—ã–π –≥–µ–Ω–µ—Ä–∞—Ç–æ—Ä –≥–æ—Ç–æ–≤ - —É–¥–∞–ª—è–µ–º –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä
		remove_generator_indicator(self, token_key)
	end
	
	-- –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–µ –≥–µ–Ω–µ—Ä–∞—Ç–æ—Ä—ã
	if is_auto_reloading then
		-- –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–π –≥–µ–Ω–µ—Ä–∞—Ç–æ—Ä –Ω–∞ –ø–µ—Ä–µ–∑–∞—Ä—è–¥–∫–µ - –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –∏–ª–∏ –æ–±–Ω–æ–≤–ª—è–µ–º –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä
		if self.generator_auto_indicators[token_key] then
			-- –ò–Ω–¥–∏–∫–∞—Ç–æ—Ä —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç - –æ–±–Ω–æ–≤–ª—è–µ–º –ø—Ä–æ–≥—Ä–µ—Å—Å
			self.generator_auto_indicators[token_key]:set_progress(auto_reload_progress)
		else
			-- –°–æ–∑–¥–∞—ë–º –Ω–æ–≤—ã–π –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä –¥–ª—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–≥–æ –≥–µ–Ω–µ—Ä–∞—Ç–æ—Ä–∞
			show_generator_indicator(self, generator_id, token_key, token, auto_reload_progress, "automatic")
		end
	else
		-- –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–π –≥–µ–Ω–µ—Ä–∞—Ç–æ—Ä –≥–æ—Ç–æ–≤ - —É–¥–∞–ª—è–µ–º –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä
		remove_generator_auto_indicator(self, token_key)
	end
end

-- –§—É–Ω–∫—Ü–∏—è –ø–æ–∫–∞–∑–∞ –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä–∞ –ø–µ—Ä–µ–∑–∞—Ä—è–¥–∫–∏ –≥–µ–Ω–µ—Ä–∞—Ç–æ—Ä–∞
function show_generator_indicator(self, generator_id, token_key, token, progress, type)
	-- –ò–∑–≤–ª–µ–∫–∞–µ–º –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –∏–∑ –∫–ª—é—á–∞ —Ç–æ–∫–µ–Ω–∞
	local grid_x, grid_y = utils.parse_token_key(token_key)
	if not grid_x or not grid_y then
		print("BOARD: ERROR - Cannot parse token key: " .. token_key)
		return
	end
	
	-- –°–æ–∑–¥–∞–µ–º –Ω–æ–≤—ã–π –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä
	local token_pos = grid_to_screen(grid_x, grid_y)
	token_pos.z = 0
	local indicator_pos, indicator_scale, indicator_color
	
	if type == "manual" then
		-- –†—É—á–Ω—ã–µ –≥–µ–Ω–µ—Ä–∞—Ç–æ—Ä—ã: —Å–∏–Ω–∏–π —Ü–≤–µ—Ç, –ø—Ä–∞–≤—ã–π –≤–µ—Ä—Ö–Ω–∏–π —É–≥–æ–ª
		indicator_pos = vmath.vector3(
			token_pos.x + CELL_SIZE * 0.25,  -- –°–º–µ—â–µ–Ω–∏–µ –≤–ø—Ä–∞–≤–æ
			token_pos.y + CELL_SIZE * 0.25,  -- –°–º–µ—â–µ–Ω–∏–µ –≤–≤–µ—Ä—Ö
			0.6 -- —Ñ–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ, —á—Ç–æ–±—ã –≤—Å–µ —á–∞—Å—Ç–∏ –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä–∞ –±—ã–ª–∏ –≤–∏–¥–∏–º—ã
		)
		indicator_scale = vmath.vector3(0.25, 0.25, 1) -- –£–º–µ–Ω—å—à–µ–Ω –≤ 4 —Ä–∞–∑–∞
		indicator_color = vmath.vector4(0.2, 0.6, 1.0, 1) -- –°–∏–Ω–∏–π —Ü–≤–µ—Ç
		
		-- –ï—Å–ª–∏ –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç, –æ–±–Ω–æ–≤–ª—è–µ–º –µ–≥–æ –ø—Ä–æ–≥—Ä–µ—Å—Å
		if self.generator_indicators[token_key] then
			self.generator_indicators[token_key]:set_progress(progress)
			return
		end
		
		print("DEBUG: SHOW_MANUAL_INDICATOR: token_pos = (" .. tostring(token_pos.x) .. ", " .. tostring(token_pos.y) .. ", " .. tostring(token_pos.z) .. ") indicator_pos = (" .. tostring(indicator_pos.x) .. ", " .. tostring(indicator_pos.y) .. ", " .. tostring(indicator_pos.z) .. ") for key " .. tostring(token_key))
		
		local indicator = Indicator:new(indicator_pos, indicator_scale)
		indicator:set_color(indicator_color)
		indicator:set_progress(progress)
		
		self.generator_indicators[token_key] = indicator
		debug_logger.log_important("Created manual reload indicator for generator " .. generator_id .. " at " .. token_key, 5.0)
		
	elseif type == "automatic" then
		-- –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–µ –≥–µ–Ω–µ—Ä–∞—Ç–æ—Ä—ã: –∑–µ–ª–µ–Ω—ã–π —Ü–≤–µ—Ç, –ª–µ–≤—ã–π –≤–µ—Ä—Ö–Ω–∏–π —É–≥–æ–ª
		indicator_pos = vmath.vector3(
			token_pos.x - CELL_SIZE * 0.25,  -- –°–º–µ—â–µ–Ω–∏–µ –≤–ª–µ–≤–æ
			token_pos.y + CELL_SIZE * 0.25,  -- –°–º–µ—â–µ–Ω–∏–µ –≤–≤–µ—Ä—Ö
			0.6 -- —Ñ–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ, —á—Ç–æ–±—ã –≤—Å–µ —á–∞—Å—Ç–∏ –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä–∞ –±—ã–ª–∏ –≤–∏–¥–∏–º—ã
		)
		indicator_scale = vmath.vector3(0.25, 0.25, 1) -- –£–º–µ–Ω—å—à–µ–Ω –≤ 4 —Ä–∞–∑–∞
		indicator_color = vmath.vector4(0.2, 1.0, 0.2, 1) -- –ó–µ–ª–µ–Ω—ã–π —Ü–≤–µ—Ç
		
		-- –ï—Å–ª–∏ –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç, –æ–±–Ω–æ–≤–ª—è–µ–º –µ–≥–æ –ø—Ä–æ–≥—Ä–µ—Å—Å
		if self.generator_auto_indicators[token_key] then
			self.generator_auto_indicators[token_key]:set_progress(progress)
			return
		end
		
		print("DEBUG: SHOW_AUTO_INDICATOR: token_pos = (" .. tostring(token_pos.x) .. ", " .. tostring(token_pos.y) .. ", " .. tostring(token_pos.z) .. ") indicator_pos = (" .. tostring(indicator_pos.x) .. ", " .. tostring(indicator_pos.y) .. ", " .. tostring(indicator_pos.z) .. ") for key " .. tostring(token_key))
		
		local indicator = Indicator:new(indicator_pos, indicator_scale)
		indicator:set_color(indicator_color)
		indicator:set_progress(progress)
		
		self.generator_auto_indicators[token_key] = indicator
		debug_logger.log_important("Created automatic reload indicator for generator " .. generator_id .. " at " .. token_key, 5.0)
	end
end

-- –§—É–Ω–∫—Ü–∏—è —É–¥–∞–ª–µ–Ω–∏—è –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä–∞ –ø–µ—Ä–µ–∑–∞—Ä—è–¥–∫–∏ –≥–µ–Ω–µ—Ä–∞—Ç–æ—Ä–∞
function remove_generator_indicator(self, token_key)
	if self.generator_indicators[token_key] then
		self.generator_indicators[token_key]:destroy()
		self.generator_indicators[token_key] = nil
		debug_logger.log_important("Removed manual reload indicator for generator at " .. token_key, 5.0)
		if self.tokens and self.tokens[token_key] and self.tokens[token_key].id then
			local pos = go.get_position(self.tokens[token_key].id)
			print("DEBUG: REMOVE_MANUAL_INDICATOR: token_pos = (" .. tostring(pos.x) .. ", " .. tostring(pos.y) .. ", " .. tostring(pos.z) .. ") for key " .. tostring(token_key))
		end
	end
end

-- –§—É–Ω–∫—Ü–∏—è —É–¥–∞–ª–µ–Ω–∏—è –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä–∞ –ø–µ—Ä–µ–∑–∞—Ä—è–¥–∫–∏ –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–≥–æ –≥–µ–Ω–µ—Ä–∞—Ç–æ—Ä–∞
function remove_generator_auto_indicator(self, token_key)
	if self.generator_auto_indicators[token_key] then
		self.generator_auto_indicators[token_key]:destroy()
		self.generator_auto_indicators[token_key] = nil
		debug_logger.log_important("Removed automatic reload indicator for generator at " .. token_key, 5.0)
		if self.tokens and self.tokens[token_key] and self.tokens[token_key].id then
			local pos = go.get_position(self.tokens[token_key].id)
			print("DEBUG: REMOVE_AUTO_INDICATOR: token_pos = (" .. tostring(pos.x) .. ", " .. tostring(pos.y) .. ", " .. tostring(pos.z) .. ") for key " .. tostring(token_key))
		end
	end
end

-- –§—É–Ω–∫—Ü–∏—è –∞–∫—Ç–∏–≤–∞—Ü–∏–∏ –≥–µ–Ω–µ—Ä–∞—Ç–æ—Ä–∞ –ø–æ token_key
function activate_generator_token(self, token_key)
    local token = self.tokens[token_key]
    if not token then return false, "No token" end
    
    local generator_id = utils.create_token_string(token.evo_id, token.level)
    local generator = generator_config.get_generator(generator_id)
    if not generator or not generator.manual then return false, "No generator config" end
    
    -- –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–µ –Ω–∞ –ø–µ—Ä–µ–∑–∞—Ä—è–¥–∫–µ –ª–∏ –≥–µ–Ω–µ—Ä–∞—Ç–æ—Ä
    if token.is_reloading then return false, "Still reloading" end
    
    -- –ü—Ä–æ–≤–µ—Ä—è–µ–º –µ–º–∫–æ—Å—Ç—å
    if not token.current_capacity or token.current_capacity <= 0 then return false, "No capacity left" end
    
    -- –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–µ –∏—Å—á–µ—Ä–ø–∞–Ω –ª–∏ –ª–∏–º–∏—Ç —Ü–∏–∫–ª–æ–≤ –¥–ª—è –æ–¥–Ω–æ—Ä–∞–∑–æ–≤–æ–≥–æ –≥–µ–Ω–µ—Ä–∞—Ç–æ—Ä–∞
    if generator_config.is_disposable(generator_id) then
        local remaining_cycles = generator_config.get_remaining_cycles(generator_id)
        if remaining_cycles and remaining_cycles <= 0 then
            return false, "Disposable generator exhausted"
        end
    end
    
    -- –£–º–µ–Ω—å—à–∞–µ–º –µ–º–∫–æ—Å—Ç—å
    token.current_capacity = token.current_capacity - 1
    
    -- –ü—Ä–æ–≤–µ—Ä—è–µ–º, –∑–∞–≤–µ—Ä—à–∏–ª—Å—è –ª–∏ —Ü–∏–∫–ª –¥–ª—è –æ–¥–Ω–æ—Ä–∞–∑–æ–≤–æ–≥–æ –≥–µ–Ω–µ—Ä–∞—Ç–æ—Ä–∞
    if generator_config.is_disposable(generator_id) and token.current_capacity <= 0 then
        generator_config.increment_cycle_count(generator_id)
        print("BOARD: Completed cycle for disposable generator " .. generator_id)
    end
    
    -- –ï—Å–ª–∏ –µ–º–∫–æ—Å—Ç—å –∑–∞–∫–æ–Ω—á–∏–ª–∞—Å—å, –∑–∞–ø—É—Å–∫–∞–µ–º –ø–µ—Ä–µ–∑–∞—Ä—è–¥–∫—É
    if token.current_capacity <= 0 and generator.manual.reload_sec then
        token.is_reloading = true
        token.reload_start_time = os.clock()
        token.reload_end_time = token.reload_start_time + generator.manual.reload_sec
    end
    
    return true
end

function is_generator_reloading(self, token_key)
    local token = self.tokens[token_key]
    if not token then return false end
    
    -- –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ä—É—á–Ω—ã–µ –≥–µ–Ω–µ—Ä–∞—Ç–æ—Ä—ã
    if token.is_reloading then
        if os.clock() >= token.reload_end_time then
            token.is_reloading = false
            local generator = generator_config.get_generator(utils.create_token_string(token.evo_id, token.level))
            if generator and generator.manual then
                token.current_capacity = generator.manual.capacity
                
                -- –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–µ –∏—Å—á–µ—Ä–ø–∞–Ω –ª–∏ –ª–∏–º–∏—Ç —Ü–∏–∫–ª–æ–≤ –¥–ª—è –æ–¥–Ω–æ—Ä–∞–∑–æ–≤–æ–≥–æ –≥–µ–Ω–µ—Ä–∞—Ç–æ—Ä–∞
                if generator_config.is_disposable(utils.create_token_string(token.evo_id, token.level)) then
                    local remaining_cycles = generator_config.get_remaining_cycles(utils.create_token_string(token.evo_id, token.level))
                    if remaining_cycles and remaining_cycles <= 0 then
                        print("BOARD: Disposable generator exhausted after reload, will be disposed on next activation")
                    end
                end
            end
            
            -- –û–±–Ω–æ–≤–ª—è–µ–º –∏–∫–æ–Ω–∫–∏ –≥–µ–Ω–µ—Ä–∞—Ç–æ—Ä–æ–≤ –ø–æ—Å–ª–µ –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è –ø–µ—Ä–µ–∑–∞—Ä—è–¥–∫–∏
            update_generator_icons(self)
        end
        return true
    end
    
    -- –ü—Ä–æ–≤–µ—Ä—è–µ–º –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–µ –≥–µ–Ω–µ—Ä–∞—Ç–æ—Ä—ã
    if token.is_auto_reloading then
        if token.auto_reload_timer and token.auto_reload_timer >= (generator_config.get_generator(utils.create_token_string(token.evo_id, token.level)) and generator_config.get_generator(utils.create_token_string(token.evo_id, token.level)).automatic and generator_config.get_generator(utils.create_token_string(token.evo_id, token.level)).automatic.reload_sec or 0) then
            token.is_auto_reloading = false
            token.auto_reload_timer = 0
            local generator = generator_config.get_generator(utils.create_token_string(token.evo_id, token.level))
            if generator and generator.automatic then
                token.auto_capacity = generator.automatic.capacity or 0
            end
            update_generator_icons(self)
        else
            return true
        end
    end
    
    return false
end

function get_generator_reload_progress(self, token_key)
    local token = self.tokens[token_key]
    if not token then return 1.0 end
    
    -- –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ä—É—á–Ω—ã–µ –≥–µ–Ω–µ—Ä–∞—Ç–æ—Ä—ã
    if token.is_reloading then
        local generator = generator_config.get_generator(utils.create_token_string(token.evo_id, token.level))
        if not generator or not generator.manual then return 1.0 end
        local total = generator.manual.reload_sec
        local elapsed = os.clock() - token.reload_start_time
        return math.min(elapsed / total, 1.0)
    end
    
    return 1.0
end

function get_generator_auto_reload_progress(self, token_key)
    local token = self.tokens[token_key]
    if not token then return 1.0 end
    
    -- –ü—Ä–æ–≤–µ—Ä—è–µ–º –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–µ –≥–µ–Ω–µ—Ä–∞—Ç–æ—Ä—ã
    if token.is_auto_reloading then
        local generator = generator_config.get_generator(utils.create_token_string(token.evo_id, token.level))
        if not generator or not generator.automatic then return 1.0 end
        local total = generator.automatic.reload_sec or 0
        if total <= 0 then return 1.0 end
        local elapsed = token.auto_reload_timer or 0
        return math.min(elapsed / total, 1.0)
    end
    
    return 1.0
end

-- –§—É–Ω–∫—Ü–∏—è –∞–∫—Ç–∏–≤–∞—Ü–∏–∏ –≥–µ–Ω–µ—Ä–∞—Ç–æ—Ä–∞
function activate_generator(self, token_key, cell)
    local ok, err = activate_generator_token(self, token_key)
    if not ok then
        print("BOARD: Generator cannot be activated: " .. (err or "unknown error"))
        return
    end
    
    local token = self.tokens[token_key]
    local generator_id = utils.create_token_string(token.evo_id, token.level)
    local output_token, error_msg = generator_config.get_random_manual_output(generator_id)
    
    if output_token then
        print("BOARD: Generator " .. generator_id .. " generated: " .. output_token)
        drop_token_from_generator(self, output_token, cell)
        update_generator_visual(self, generator_id, token_key, token)
    else
        print("BOARD: Generator " .. generator_id .. " failed to generate: " .. (error_msg or "unknown error"))
    end
    
    -- –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω—É–∂–Ω–æ –ª–∏ —É–Ω–∏—á—Ç–æ–∂–∏—Ç—å –æ–¥–Ω–æ—Ä–∞–∑–æ–≤—ã–π –≥–µ–Ω–µ—Ä–∞—Ç–æ—Ä
    if generator_config.should_dispose(generator_id) then
        handle_disposable_generator_disposal(self, token_key)
    end
    
    -- –û–±–Ω–æ–≤–ª—è–µ–º –∏–∫–æ–Ω–∫–∏ –≥–µ–Ω–µ—Ä–∞—Ç–æ—Ä–æ–≤ –ø–æ—Å–ª–µ –∞–∫—Ç–∏–≤–∞—Ü–∏–∏
    update_generator_icons(self)
end

-- –§—É–Ω–∫—Ü–∏—è –≤—ã–±—Ä–æ—Å–∞ —Ñ–∏—à–∫–∏ –∏–∑ –≥–µ–Ω–µ—Ä–∞—Ç–æ—Ä–∞
function drop_token_from_generator(self, token_string, generator_cell)
	-- –ü–∞—Ä—Å–∏–º —Å—Ç—Ä–æ–∫—É —Ç–æ–∫–µ–Ω–∞
	local evo_id, level = utils.parse_token_string(token_string)
	if not evo_id or not level then
		print("BOARD: ERROR - Invalid token string: " .. token_string)
		return
	end
	
	-- –û–ø—Ä–µ–¥–µ–ª—è–µ–º —Ç–∏–ø –∏—Å—Ö–æ–¥–Ω–æ–≥–æ –≥–µ–Ω–µ—Ä–∞—Ç–æ—Ä–∞ –¥–ª—è –≤—ã–±–æ—Ä–∞ —Å—Ç—Ä–∞—Ç–µ–≥–∏–∏ –¥—Ä–æ–ø–∞
	local target_cell = nil
	
	-- –ü—Ä–æ–≤–µ—Ä—è–µ–º, –µ—Å—Ç—å –ª–∏ –≥–µ–Ω–µ—Ä–∞—Ç–æ—Ä –≤ –∏—Å—Ö–æ–¥–Ω–æ–π –∫–ª–µ—Ç–∫–µ
	local generator_key = utils.get_token_key(generator_cell.x, generator_cell.y)
	local source_token = self.tokens[generator_key]
	
	if source_token then
		local source_generator_id = utils.create_token_string(source_token.evo_id, source_token.level)
		local source_generator = generator_config.get_generator(source_generator_id)
		
		print("BOARD: Drop from generator " .. source_generator_id .. " at (" .. generator_cell.x .. ", " .. generator_cell.y .. ")")
		
		-- –ü—Ä–æ–≤–µ—Ä—è–µ–º, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ –≥–µ–Ω–µ—Ä–∞—Ç–æ—Ä –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–º (–∏–º–µ–µ—Ç –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫—É—é –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—é —Å –µ–º–∫–æ—Å—Ç—å—é –∏ —Ç–∞–π–º–µ—Ä–æ–º)
		if source_generator and source_generator.automatic and 
		   source_generator.automatic.capacity and source_generator.automatic.capacity > 0 and
		   source_generator.automatic.timer_sec and source_generator.automatic.timer_sec > 0 then
			-- –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–µ –≥–µ–Ω–µ—Ä–∞—Ç–æ—Ä—ã –∏—Å–ø–æ–ª—å–∑—É—é—Ç –±–ª–∏–∂–Ω–∏–π –¥—Ä–æ–ø
			print("BOARD: Using nearest drop for automatic generator")
			local adjacent_cells = find_adjacent_empty_cells(self, generator_cell.x, generator_cell.y)
			print("BOARD: Found " .. #adjacent_cells .. " adjacent empty cells")
			
			if #adjacent_cells > 0 then
				-- –í—ã–±–∏—Ä–∞–µ–º —Å–ª—É—á–∞–π–Ω—É—é —Å–æ—Å–µ–¥–Ω—é—é –∫–ª–µ—Ç–∫—É
				target_cell = adjacent_cells[math.random(1, #adjacent_cells)]
				print("BOARD: Selected adjacent cell (" .. target_cell.x .. ", " .. target_cell.y .. ")")
			else
				-- –ï—Å–ª–∏ —Å–æ—Å–µ–¥–Ω–∏—Ö –∫–ª–µ—Ç–æ–∫ –Ω–µ—Ç, –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–π –≥–µ–Ω–µ—Ä–∞—Ç–æ—Ä –Ω–µ –¥—Ä–æ–ø–∞–µ—Ç —Ñ–∏—à–∫—É
				print("BOARD: No adjacent cells available for automatic generator - skipping drop")
				return
			end
		else
			-- –†—É—á–Ω—ã–µ –≥–µ–Ω–µ—Ä–∞—Ç–æ—Ä—ã –∏—Å–ø–æ–ª—å–∑—É—é—Ç –æ–±—ã—á–Ω—ã–π –¥—Ä–æ–ø (–ª—é–±–∞—è —Å–≤–æ–±–æ–¥–Ω–∞—è –∫–ª–µ—Ç–∫–∞)
			print("BOARD: Using normal drop for manual generator")
			target_cell = find_nearest_empty_cell(self, generator_cell.x, generator_cell.y)
		end
	else
		-- –ï—Å–ª–∏ –≥–µ–Ω–µ—Ä–∞—Ç–æ—Ä –Ω–µ –Ω–∞–π–¥–µ–Ω, –∏—Å–ø–æ–ª—å–∑—É–µ–º –æ–±—ã—á–Ω—ã–π –¥—Ä–æ–ø
		print("BOARD: Generator not found, using normal drop")
		target_cell = find_nearest_empty_cell(self, generator_cell.x, generator_cell.y)
	end
	
	if not target_cell then
		print("BOARD: No empty cells available for drop")
		return
	end
	
	-- –°–æ–∑–¥–∞–µ–º —Ñ–∏—à–∫—É —Å –ø–æ–º–æ—â—å—é —É–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω–æ–π —Ñ—É–Ω–∫—Ü–∏–∏
	local token_key = create_token_on_board(self, evo_id, level, target_cell.x, target_cell.y, -2) -- –°–∫—Ä—ã—Ç–∞ –≤–æ –≤—Ä–µ–º—è –ø–æ–ª—ë—Ç–∞
	local token_id = self.tokens[token_key].id
	
	-- –ï—Å–ª–∏ –≤—ã–±—Ä–æ—à–µ–Ω–Ω–∞—è —Ñ–∏—à–∫–∞ —è–≤–ª—è–µ—Ç—Å—è –≥–µ–Ω–µ—Ä–∞—Ç–æ—Ä–æ–º, –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º –µ–≥–æ
	local dropped_generator_id = utils.create_token_string(evo_id, level)
	if generator_config.is_generator(dropped_generator_id) then
		print("BOARD: Initialized dropped generator " .. dropped_generator_id .. " with capacity " .. tostring(self.tokens[token_key].current_capacity))
	end
	
	-- –°–æ–∑–¥–∞–µ–º –∞–Ω–∏–º–∞—Ü–∏—é –ø–æ–ª–µ—Ç–∞ –æ—Ç –≥–µ–Ω–µ—Ä–∞—Ç–æ—Ä–∞ –∫ —Ü–µ–ª–µ–≤–æ–π –∫–ª–µ—Ç–∫–µ
	create_drop_animation(self, token_id, generator_cell, target_cell)
	
	print("BOARD: Token dropped: " .. token_string .. " at grid(" .. target_cell.x .. ", " .. target_cell.y .. ")")
end

-- –§—É–Ω–∫—Ü–∏—è —Å–æ–∑–¥–∞–Ω–∏—è –∞–Ω–∏–º–∞—Ü–∏–∏ –ø–æ–ª–µ—Ç–∞ —Ñ–∏—à–∫–∏
function create_drop_animation(self, token_id, from_cell, to_cell)
	-- –ù–∞—á–∞–ª—å–Ω–∞—è –ø–æ–∑–∏—Ü–∏—è (—É –≥–µ–Ω–µ—Ä–∞—Ç–æ—Ä–∞)
	local start_pos = grid_to_screen(from_cell.x, from_cell.y)
	start_pos.z = 0
	
	-- –ö–æ–Ω–µ—á–Ω–∞—è –ø–æ–∑–∏—Ü–∏—è (—Ü–µ–ª–µ–≤–∞—è –∫–ª–µ—Ç–∫–∞)
	local end_pos = grid_to_screen(to_cell.x, to_cell.y)
	end_pos.z = 0
	
	-- –ê–Ω–∏–º–∞—Ü–∏—è –ø–æ–ª–µ—Ç–∞
	local duration = 0.17 -- —Å–µ–∫—É–Ω–¥—ã (—É—Å–∫–æ—Ä–µ–Ω–æ –≤ 3 —Ä–∞–∑–∞)
	local start_time = os.clock()
	
	-- –î–æ–±–∞–≤–ª—è–µ–º –≤ —Å–ø–∏—Å–æ–∫ –∞–Ω–∏–º–∏—Ä—É–µ–º—ã—Ö —Ñ–∏—à–µ–∫
	table.insert(self.animating_tokens, {
		token_id = token_id,
		start_pos = start_pos,
		end_pos = end_pos,
		start_time = start_time,
		duration = duration
	})
	
	-- –°—Ä–∞–∑—É –ø–µ—Ä–µ–º–µ—â–∞–µ–º —Ñ–∏—à–∫—É –Ω–∞ –Ω–∞—á–∞–ª—å–Ω—É—é –ø–æ–∑–∏—Ü–∏—é –¥–ª—è –∞–Ω–∏–º–∞—Ü–∏–∏
	msg.post(token_id, "set_position", { position = start_pos })
end

-- –ù–û–í–ê–Ø –°–ò–°–¢–ï–ú–ê: –§—É–Ω–∫—Ü–∏—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è –º–µ—Ä–¥–∂–∞
function perform_merge(self, target_cell, target_token, target_key)
	-- –ü–æ–ª—É—á–∞–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç —Å–ª–∏—è–Ω–∏—è –∏–∑ —ç–≤–æ–ª—é—Ü–∏–æ–Ω–Ω—ã—Ö —Ç–∞–±–ª–∏—Ü
	local merge_result = evolution_tables.get_merge_result(target_token.evo_id, target_token.level)
	
	if merge_result then
		-- –°–Ω–∞—á–∞–ª–∞ –ø—ã—Ç–∞–µ–º—Å—è —Å–æ–∑–¥–∞—Ç—å –Ω–æ–≤—ã–π —Ç–æ–∫–µ–Ω
		local token_key = create_token_on_board(self, merge_result.evo_id, merge_result.level, target_cell.x, target_cell.y)
		
		-- –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ —Ç–æ–∫–µ–Ω –±—ã–ª —Å–æ–∑–¥–∞–Ω —É—Å–ø–µ—à–Ω–æ
		if not token_key then
			print("ERROR: Merge failed - could not create new token, keeping original tokens")
			return
		end
		
		-- –¢–æ–ª—å–∫–æ –ø–æ—Å–ª–µ —É—Å–ø–µ—à–Ω–æ–≥–æ —Å–æ–∑–¥–∞–Ω–∏—è –Ω–æ–≤–æ–≥–æ —Ç–æ–∫–µ–Ω–∞ —É–¥–∞–ª—è–µ–º —Å—Ç–∞—Ä—ã–µ
		-- –£–¥–∞–ª—è–µ–º –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä—ã –≥–µ–Ω–µ—Ä–∞—Ç–æ—Ä–æ–≤ –µ—Å–ª–∏ –æ–Ω–∏ –µ—Å—Ç—å
		local dragged_generator_id = utils.create_token_string(self.dragged_evo_id, self.dragged_level)
		local target_generator_id = utils.create_token_string(target_token.evo_id, target_token.level)
		
		if generator_config.is_generator(dragged_generator_id) then
			local dragged_key = utils.get_token_key(self.dragged_from.x, self.dragged_from.y)
			remove_generator_indicator(self, dragged_key)
			print("BOARD: Removed indicator for dragged generator " .. dragged_generator_id)
		end
		
		if generator_config.is_generator(target_generator_id) then
			remove_generator_indicator(self, target_key)
			print("BOARD: Removed indicator for target generator " .. target_generator_id)
		end
		
		-- –£–¥–∞–ª—è–µ–º —Å—Ç–∞—Ä—ã–µ —Ñ–∏—à–∫–∏ (—Å –ø—Ä–æ–≤–µ—Ä–∫–æ–π —Å—É—â–µ—Å—Ç–≤–æ–≤–∞–Ω–∏—è)
		if target_token and target_token.id and go.exists(target_token.id) then
			go.delete(target_token.id)
		end
		if self.dragged_token and go.exists(self.dragged_token) then
			go.delete(self.dragged_token)
		end
		
		local new_token = self.tokens[token_key]
		print("BOARD: Created merged token " .. merge_result.evo_id .. " level " .. merge_result.level .. " at grid(" .. target_cell.x .. ", " .. target_cell.y .. ") key=" .. tostring(token_key))
		print("DEBUG: MERGE - new_token.id=" .. tostring(new_token and new_token.id) .. ", new_token exists=" .. tostring(new_token ~= nil))
		-- –û—á–∏—â–∞–µ–º –¥–∞–Ω–Ω—ã–µ –æ–± –∏—Å—Ö–æ–¥–Ω–æ–π –ø–æ–∑–∏—Ü–∏–∏ –ø–µ—Ä–µ—Ç–∞—Å–∫–∏–≤–∞–µ–º–æ–π —Ñ–∏—à–∫–∏
		local dragged_key = utils.get_token_key(self.dragged_from.x, self.dragged_from.y)
		if self.tokens[dragged_key] then
			-- –û—á–∏—â–∞–µ–º –∏–∫–æ–Ω–∫—É –≥–µ–Ω–µ—Ä–∞—Ç–æ—Ä–∞ –µ—Å–ª–∏ –±—ã–ª–∞
			hide_generator_icon(self, self.dragged_from.x, self.dragged_from.y)
			self.tokens[dragged_key] = nil
			print("BOARD: Cleared dragged token data from (" .. self.dragged_from.x .. ", " .. self.dragged_from.y .. ")")
		end
		-- –û–±–Ω–æ–≤–ª—è–µ–º –≤–∏–∑—É–∞–ª –Ω–æ–≤–æ–π —Ñ–∏—à–∫–∏
		local new_generator_id = utils.create_token_string(merge_result.evo_id, merge_result.level)
		if generator_config.is_generator(new_generator_id) then
			local new_token = self.tokens[token_key]
			update_generator_visual(self, new_generator_id, token_key, new_token)
			print("BOARD: Updated indicator for merged generator " .. new_generator_id)
		end
		local item_name = evolution_tables.get_item_name(merge_result.evo_id, merge_result.level)
		print("BOARD: Merge completed - new token " .. merge_result.evo_id .. " level " .. merge_result.level .. " (" .. item_name .. ") at (" .. target_cell.x .. ", " .. target_cell.y .. ")")
		-- –ï—Å–ª–∏ –±—ã–ª–∞ –≤—ã–¥–µ–ª–µ–Ω–∞ –æ–¥–Ω–∞ –∏–∑ –∏—Å—Ö–æ–¥–Ω—ã—Ö –ø–æ–∑–∏—Ü–∏–π, –≤—ã–¥–µ–ª—è–µ–º –Ω–æ–≤—É—é —Ñ–∏—à–∫—É
		if self.pre_drag_selection and 
		   ((self.pre_drag_selection.x == self.dragged_from.x and self.pre_drag_selection.y == self.dragged_from.y) or
		    (self.pre_drag_selection.x == target_cell.x and self.pre_drag_selection.y == target_cell.y)) then
			print("BOARD: Selecting merged token at (" .. target_cell.x .. ", " .. target_cell.y .. ")")
			select_cell(self, target_cell.x, target_cell.y)
		end
		check_selection_after_drag(self)
	else
		print("BOARD: Merge failed - no evolution result for " .. target_token.evo_id .. " level " .. target_token.level)
	end
end

-- –ù–û–í–ê–Ø –°–ò–°–¢–ï–ú–ê: –§—É–Ω–∫—Ü–∏—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è –ø–µ—Ä–µ–º–µ—â–µ–Ω–∏—è
function perform_move(self, target_cell)
    local pos = grid_to_screen(target_cell.x, target_cell.y)
    pos.z = 1
    msg.post(self.dragged_token, "move_to", { position = pos, smooth = true })

    local target_key = utils.get_token_key(target_cell.x, target_cell.y)
    local old_key = utils.get_token_key(self.dragged_from.x, self.dragged_from.y)
    
    print("DEBUG: MOVE - old_key=" .. tostring(old_key) .. ", target_key=" .. tostring(target_key))
    print("DEBUG: MOVE - dragged_from=(" .. self.dragged_from.x .. "," .. self.dragged_from.y .. ")")
    print("DEBUG: MOVE - self.tokens[old_key] exists: " .. tostring(self.tokens[old_key] ~= nil))
    
    -- –¢–æ–∫–µ–Ω –¥–æ–ª–∂–µ–Ω —Å—É—â–µ—Å—Ç–≤–æ–≤–∞—Ç—å, —Ç–∞–∫ –∫–∞–∫ –º—ã –µ–≥–æ –Ω–µ —É–¥–∞–ª—è–ª–∏ –ø—Ä–∏ –Ω–∞—á–∞–ª–µ –ø–µ—Ä–µ—Ç–∞—Å–∫–∏–≤–∞–Ω–∏—è
    if not self.tokens[old_key] then
        print("ERROR: MOVE - self.tokens[old_key] is nil! This shouldn't happen.")
        return
    end
    
    self.tokens[target_key] = self.tokens[old_key]
    self.tokens[target_key].id = self.dragged_token
    self.tokens[target_key].level = self.dragged_level
    self.tokens[target_key].evo_id = self.dragged_evo_id
    if old_key ~= target_key then
        -- –û—á–∏—â–∞–µ–º –∏–∫–æ–Ω–∫—É –≥–µ–Ω–µ—Ä–∞—Ç–æ—Ä–∞ —Å–æ —Å—Ç–∞—Ä–æ–π –ø–æ–∑–∏—Ü–∏–∏ –µ—Å–ª–∏ –±—ã–ª–∞
        hide_generator_icon(self, self.dragged_from.x, self.dragged_from.y)
        self.tokens[old_key] = nil
    end

    msg.post(self.dragged_token, "set_grid_position", { grid_x = target_cell.x, grid_y = target_cell.y })

    -- –ï—Å–ª–∏ –ø–µ—Ä–µ–º–µ—â–∞–µ–º—ã–π —Ç–æ–∫–µ–Ω —è–≤–ª—è–µ—Ç—Å—è –≥–µ–Ω–µ—Ä–∞—Ç–æ—Ä–æ–º, –≤–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –µ–≥–æ –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä –Ω–∞ –Ω–æ–≤–æ–π –ø–æ–∑–∏—Ü–∏–∏
    local generator_id = utils.create_token_string(self.dragged_evo_id, self.dragged_level)
    if generator_config.is_generator(generator_id) then
        local token = self.tokens[target_key]
        update_generator_visual(self, generator_id, target_key, token)
        print("BOARD: Restored indicator for moved generator " .. generator_id .. " at new position")
    end

    print("BOARD: Move completed - token " .. self.dragged_evo_id .. " level " .. self.dragged_level .. " moved to (" .. target_cell.x .. ", " .. target_cell.y .. ")")

    -- –ï—Å–ª–∏ –±—ã–ª–∞ –≤—ã–¥–µ–ª–µ–Ω–∞ –∏—Å—Ö–æ–¥–Ω–∞—è –ø–æ–∑–∏—Ü–∏—è, –≤—ã–¥–µ–ª—è–µ–º –Ω–æ–≤—É—é –ø–æ–∑–∏—Ü–∏—é
    if self.pre_drag_selection and 
       self.pre_drag_selection.x == self.dragged_from.x and 
       self.pre_drag_selection.y == self.dragged_from.y then
        print("BOARD: Moving selection from (" .. self.dragged_from.x .. ", " .. self.dragged_from.y .. ") to (" .. target_cell.x .. ", " .. target_cell.y .. ")")
        select_cell(self, target_cell.x, target_cell.y)
    end

    -- –ü—Ä–æ–≤–µ—Ä—è–µ–º –≤—ã–¥–µ–ª–µ–Ω–∏–µ –ø–æ—Å–ª–µ –ø–µ—Ä–µ–º–µ—â–µ–Ω–∏—è
    check_selection_after_drag(self)
end

-- –ù–û–í–ê–Ø –°–ò–°–¢–ï–ú–ê: –§—É–Ω–∫—Ü–∏—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è –≤–æ–∑–≤—Ä–∞—Ç–∞
function perform_return(self)
	-- –í–æ–∑–≤—Ä–∞—â–∞–µ–º —Ñ–∏—à–∫—É –Ω–∞ –∏—Å—Ö–æ–¥–Ω—É—é –ø–æ–∑–∏—Ü–∏—é
	local pos = grid_to_screen(self.dragged_from.x, self.dragged_from.y)
	pos.z = 0
	msg.post(self.dragged_token, "move_to", { position = pos, smooth = true })
	
	-- –í–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –¥–∞–Ω–Ω—ã–µ
	local original_key = utils.get_token_key(self.dragged_from.x, self.dragged_from.y)
	local current_key = nil
	-- –ù–∞–π—Ç–∏ —Ç–µ–∫—É—â–∏–π –∫–ª—é—á –ø–æ dragged_token
	for k, v in pairs(self.tokens) do
		if v.id == self.dragged_token then
			current_key = k
			break
		end
	end
	
	print("DEBUG: RETURN - original_key=" .. tostring(original_key) .. ", current_key=" .. tostring(current_key))
	print("DEBUG: RETURN - dragged_from=(" .. self.dragged_from.x .. "," .. self.dragged_from.y .. ")")
	print("DEBUG: RETURN - self.tokens[current_key] exists: " .. tostring(current_key and self.tokens[current_key] ~= nil))
	
	-- –¢–æ–∫–µ–Ω –¥–æ–ª–∂–µ–Ω —Å—É—â–µ—Å—Ç–≤–æ–≤–∞—Ç—å, —Ç–∞–∫ –∫–∞–∫ –º—ã –µ–≥–æ –Ω–µ —É–¥–∞–ª—è–ª–∏ –ø—Ä–∏ –Ω–∞—á–∞–ª–µ –ø–µ—Ä–µ—Ç–∞—Å–∫–∏–≤–∞–Ω–∏—è
	if not current_key or not self.tokens[current_key] then
		print("ERROR: RETURN - self.tokens[current_key] is nil! This shouldn't happen.")
		return
	end
	
	self.tokens[original_key] = self.tokens[current_key]
	self.tokens[original_key].id = self.dragged_token
	self.tokens[original_key].level = self.dragged_level
	self.tokens[original_key].evo_id = self.dragged_evo_id
	if current_key ~= original_key then
		-- –û—á–∏—â–∞–µ–º –∏–∫–æ–Ω–∫—É –≥–µ–Ω–µ—Ä–∞—Ç–æ—Ä–∞ —Å —Ç–µ–∫—É—â–µ–π –ø–æ–∑–∏—Ü–∏–∏ –µ—Å–ª–∏ –±—ã–ª–∞
		hide_generator_icon(self, self.dragged_from.x, self.dragged_from.y)
		self.tokens[current_key] = nil
	end
	
	-- –ï—Å–ª–∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ–º—ã–π —Ç–æ–∫–µ–Ω —è–≤–ª—è–µ—Ç—Å—è –≥–µ–Ω–µ—Ä–∞—Ç–æ—Ä–æ–º, –≤–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –µ–≥–æ –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä
	local generator_id = utils.create_token_string(self.dragged_evo_id, self.dragged_level)
	if generator_config.is_generator(generator_id) then
		local token = self.tokens[original_key]
		update_generator_visual(self, generator_id, original_key, token)
		print("BOARD: Restored indicator for returned generator " .. generator_id)
	end
	
	print("BOARD: Return completed - token " .. self.dragged_evo_id .. " level " .. self.dragged_level .. " returned to (" .. self.dragged_from.x .. ", " .. self.dragged_from.y .. ")")
	
	-- –í–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –≤—ã–¥–µ–ª–µ–Ω–∏–µ –µ—Å–ª–∏ —Ñ–∏—à–∫–∞ –≤–µ—Ä–Ω—É–ª–∞—Å—å –Ω–∞ —Ç–æ –∂–µ –º–µ—Å—Ç–æ
	if self.pre_drag_selection and 
	   self.pre_drag_selection.x == self.dragged_from.x and 
	   self.pre_drag_selection.y == self.dragged_from.y then
		print("BOARD: Restoring selection at (" .. self.dragged_from.x .. ", " .. self.dragged_from.y .. ")")
		select_cell(self, self.dragged_from.x, self.dragged_from.y)
	end
	
	-- –ü—Ä–æ–≤–µ—Ä—è–µ–º –≤—ã–¥–µ–ª–µ–Ω–∏–µ –ø–æ—Å–ª–µ –≤–æ–∑–≤—Ä–∞—Ç–∞
	check_selection_after_drag(self)
end

-- –°–ò–°–¢–ï–ú–ê –í–´–î–ï–õ–ï–ù–ò–Ø: –§—É–Ω–∫—Ü–∏—è –ø—Ä–æ–≤–µ—Ä–∫–∏ –≤—ã–¥–µ–ª–µ–Ω–∏—è –ø–æ—Å–ª–µ –ø–µ—Ä–µ—Ç–∞—Å–∫–∏–≤–∞–Ω–∏—è
function check_selection_after_drag(self)
	print("BOARD: Checking selection after drag - current selection: " .. (self.selected_cell and ("(" .. self.selected_cell.x .. ", " .. self.selected_cell.y .. ")") or "none"))
	print("BOARD: Pre-drag selection: " .. (self.pre_drag_selection and ("(" .. self.pre_drag_selection.x .. ", " .. self.pre_drag_selection.y .. ")") or "none"))
	print("BOARD: Dragged from: " .. (self.dragged_from and ("(" .. self.dragged_from.x .. ", " .. self.dragged_from.y .. ")") or "none"))
	
	-- –ü—Ä–æ–≤–µ—Ä—è–µ–º, –µ—Å—Ç—å –ª–∏ –≤—ã–¥–µ–ª–µ–Ω–∏–µ –ø–æ—Å–ª–µ –ø–µ—Ä–µ—Ç–∞—Å–∫–∏–≤–∞–Ω–∏—è
	if self.selected_cell then
		-- –ü—Ä–æ–≤–µ—Ä—è–µ–º, –µ—Å—Ç—å –ª–∏ —Ñ–∏—à–∫–∞ –≤ –≤—ã–¥–µ–ª–µ–Ω–Ω–æ–π —è—á–µ–π–∫–µ
		local token_key = utils.get_token_key(self.selected_cell.x, self.selected_cell.y)
		local token = self.tokens[token_key]
		
		if not token then
			print("BOARD: Token not found in selected cell - clearing selection")
			-- –§–∏—à–∫–∏ –±–æ–ª—å—à–µ –Ω–µ—Ç –≤ –≤—ã–¥–µ–ª–µ–Ω–Ω–æ–π —è—á–µ–π–∫–µ - —Å–Ω–∏–º–∞–µ–º –≤—ã–¥–µ–ª–µ–Ω–∏–µ
			clear_cell_selection(self)
		else
			print("BOARD: Token found in selected cell - keeping selection")
		end
	elseif self.pre_drag_selection then
		print("BOARD: No current selection, checking pre-drag selection (" .. self.pre_drag_selection.x .. ", " .. self.pre_drag_selection.y .. ")")
		-- –ï—Å–ª–∏ –±—ã–ª–æ –≤—ã–¥–µ–ª–µ–Ω–∏–µ –¥–æ –ø–µ—Ä–µ—Ç–∞—Å–∫–∏–≤–∞–Ω–∏—è, –Ω–æ —Å–µ–π—á–∞—Å –µ–≥–æ –Ω–µ—Ç
		-- –ü—Ä–æ–≤–µ—Ä—è–µ–º, –µ—Å—Ç—å –ª–∏ —Ñ–∏—à–∫–∞ –≤ —Ç–æ–π —è—á–µ–π–∫–µ, –∫–æ—Ç–æ—Ä–∞—è –±—ã–ª–∞ –≤—ã–¥–µ–ª–µ–Ω–∞
		local token_key = utils.get_token_key(self.pre_drag_selection.x, self.pre_drag_selection.y)
		local token = self.tokens[token_key]
		
		if token then
			print("BOARD: Restoring selection to pre-drag position")
			-- –í–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –≤—ã–¥–µ–ª–µ–Ω–∏–µ
			select_cell(self, self.pre_drag_selection.x, self.pre_drag_selection.y)
		else
			print("BOARD: No token found at pre-drag position - cannot restore selection")
		end
	else
		print("BOARD: No selection to check")
	end
end

-- –ù–û–í–ê–Ø –°–ò–°–¢–ï–ú–ê: –§—É–Ω–∫—Ü–∏—è –æ—á–∏—Å—Ç–∫–∏ —Å–æ—Å—Ç–æ—è–Ω–∏—è –ø–µ—Ä–µ—Ç–∞—Å–∫–∏–≤–∞–Ω–∏—è
function clear_drag_state(self)
	-- –û—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –ø–µ—Ä–µ—Ç–∞—Å–∫–∏–≤–∞–Ω–∏–µ (—Å –ø—Ä–æ–≤–µ—Ä–∫–æ–π —Å—É—â–µ—Å—Ç–≤–æ–≤–∞–Ω–∏—è –æ–±—ä–µ–∫—Ç–∞)
	if self.dragged_token then
	msg.post(self.dragged_token, "stop_drag")
	end
	
	-- –û—á–∏—â–∞–µ–º –¥–∞–Ω–Ω—ã–µ
	self.dragged_token = nil
	self.dragged_from = nil
	self.dragged_level = nil
	self.dragged_evo_id = nil
	self.is_dragging = false
	self.last_mouse_pos = nil
	self.pre_drag_selection = nil -- –û—á–∏—â–∞–µ–º —Å–æ—Ö—Ä–∞–Ω–µ–Ω–Ω–æ–µ –≤—ã–¥–µ–ª–µ–Ω–∏–µ
	
	print("BOARD: Drag state cleared")
end

-- –§—É–Ω–∫—Ü–∏—è –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ —Ñ–∏—à–∫–µ
function show_token_info(self, evo_id, level)
	local chain = evolution_tables.get_evolution_chain(evo_id)
	local item_name = evolution_tables.get_item_name(evo_id, level)
	
	if chain and item_name then
		local info_text = chain.name .. " - –£—Ä–æ–≤–µ–Ω—å " .. level .. " - " .. item_name
		print("BOARD: INFO: " .. info_text)
		
		-- –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ –≤ UI –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏
		msg.post("main:/ui", "show_token_info", {
			chain_name = chain.name,
			level = level,
			item_name = item_name
		})
	else
		print("BOARD: ERROR: Cannot get info for evo_id='" .. tostring(evo_id) .. "' level=" .. tostring(level))
		if not chain then
			print("BOARD: ERROR: Chain not found for evo_id='" .. tostring(evo_id) .. "'")
		end
		if not item_name then
			print("BOARD: ERROR: Item name not found for evo_id='" .. tostring(evo_id) .. "' level=" .. tostring(level))
		end
	end
end

-- –§—É–Ω–∫—Ü–∏—è –¥–ª—è —Å–∫—Ä—ã—Ç–∏—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ —Ñ–∏—à–∫–µ
function hide_token_info(self)
	print("INFO: –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ —Ñ–∏—à–∫–µ —Å–∫—Ä—ã—Ç–∞")
	
	-- –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ –≤ UI –¥–ª—è —Å–∫—Ä—ã—Ç–∏—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏
	msg.post("main:/ui", "hide_token_info")
end

-- –§—É–Ω–∫—Ü–∏—è –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ –≥–µ–Ω–µ—Ä–∞—Ç–æ—Ä–æ–≤
function initialize_generators(self)
	print("BOARD: Initializing generators...")
	
	for token_key, token in pairs(self.tokens) do
		local generator_id = utils.create_token_string(token.evo_id, token.level)
		
		if generator_config.is_generator(generator_id) then
			local generator = generator_config.get_generator(generator_id)
			if generator then
				-- –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º —Ä—É—á–Ω—ã–µ –≥–µ–Ω–µ—Ä–∞—Ç–æ—Ä—ã
				if generator.manual then
					-- –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º –≥–µ–Ω–µ—Ä–∞—Ç–æ—Ä —Å –ø–æ–ª–Ω–æ–π –µ–º–∫–æ—Å—Ç—å—é
					token.current_capacity = generator.manual.capacity or 0
					token.is_reloading = false
					
					-- –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º —Å—á–µ—Ç—á–∏–∫ —Ü–∏–∫–ª–æ–≤ –¥–ª—è –æ–¥–Ω–æ—Ä–∞–∑–æ–≤—ã—Ö –≥–µ–Ω–µ—Ä–∞—Ç–æ—Ä–æ–≤
					if generator_config.is_disposable(generator_id) then
						-- –°–±—Ä–∞—Å—ã–≤–∞–µ–º —Å—á–µ—Ç—á–∏–∫ —Ü–∏–∫–ª–æ–≤ –¥–ª—è –Ω–æ–≤—ã—Ö —ç–∫–∑–µ–º–ø–ª—è—Ä–æ–≤ –æ–¥–Ω–æ—Ä–∞–∑–æ–≤—ã—Ö –≥–µ–Ω–µ—Ä–∞—Ç–æ—Ä–æ–≤
						generator.manual.completed_cycles = 0
						local remaining = generator_config.get_remaining_cycles(generator_id)
						print("BOARD: Initialized disposable generator " .. generator_id .. " with capacity " .. (generator.manual.capacity or 0) .. " and " .. (remaining or 0) .. " remaining cycles")
					else
						print("BOARD: Initialized manual generator " .. generator_id .. " with capacity " .. (generator.manual.capacity or 0))
					end
				end
				
				-- –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–µ –≥–µ–Ω–µ—Ä–∞—Ç–æ—Ä—ã
				if generator.automatic then
					token.auto_capacity = generator.automatic.capacity or 0
					token.auto_timer = 0
					token.auto_reload_timer = 0
					token.is_auto_reloading = false
					print("BOARD: Initialized automatic generator " .. generator_id .. " with capacity " .. (generator.automatic.capacity or 0))
				end
			end
		end
	end
	
	print("BOARD: Generators initialization complete")
	
	-- –û–±–Ω–æ–≤–ª—è–µ–º –∏–∫–æ–Ω–∫–∏ –≥–µ–Ω–µ—Ä–∞—Ç–æ—Ä–æ–≤ –ø–æ—Å–ª–µ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏
	update_generator_icons(self)
end

-- –§—É–Ω–∫—Ü–∏—è –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è —Ä–∞–±–æ—Ç—ã (–æ—á–∏—Å—Ç–∫–∞ —Ä–µ—Å—É—Ä—Å–æ–≤)
function final(self)
	-- –û—á–∏—â–∞–µ–º –≤—Å–µ –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä—ã –≥–µ–Ω–µ—Ä–∞—Ç–æ—Ä–æ–≤
	for token_key, indicator in pairs(self.generator_indicators) do
		if indicator then
			indicator:destroy()
		end
	end
	self.generator_indicators = {}
	print("BOARD: All manual generator indicators cleaned up")
	
	-- –û—á–∏—â–∞–µ–º –≤—Å–µ –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä—ã –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏—Ö –≥–µ–Ω–µ—Ä–∞—Ç–æ—Ä–æ–≤
	for token_key, indicator in pairs(self.generator_auto_indicators) do
		if indicator then
			indicator:destroy()
		end
	end
	self.generator_auto_indicators = {}
	print("BOARD: All automatic generator indicators cleaned up")
	
	-- –û—á–∏—â–∞–µ–º –≤—Å–µ –∏–∫–æ–Ω–∫–∏ –≥–µ–Ω–µ—Ä–∞—Ç–æ—Ä–æ–≤
	for token_key, icon_id in pairs(self.generator_icons) do
		if icon_id then
			go.delete(icon_id)
		end
	end
	self.generator_icons = {}
	print("BOARD: All generator icons cleaned up")
end

-- –§—É–Ω–∫—Ü–∏—è –ø–æ–∫–∞–∑–∞ –∏–∫–æ–Ω–∫–∏ –≥–µ–Ω–µ—Ä–∞—Ç–æ—Ä–∞
function show_generator_icon(self, grid_x, grid_y)
	local token_key = utils.get_token_key(grid_x, grid_y)
	if self.tokens[token_key] and not self.generator_icons[token_key] then
		-- –ò—Å–ø–æ–ª—å–∑—É–µ–º –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –∫–ª–µ—Ç–∫–∏ –¥–ª—è –ø–æ–∑–∏—Ü–∏–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏—è –∏–∫–æ–Ω–∫–∏
		local cell_pos = grid_to_screen(grid_x, grid_y)
		local icon_pos = vmath.vector3(
			cell_pos.x + 20,  -- –°–º–µ—â–µ–Ω–∏–µ –≤–ø—Ä–∞–≤–æ –æ—Ç —Ü–µ–Ω—Ç—Ä–∞ –∫–ª–µ—Ç–∫–∏
			cell_pos.y - 20,  -- –°–º–µ—â–µ–Ω–∏–µ –≤–Ω–∏–∑ –æ—Ç —Ü–µ–Ω—Ç—Ä–∞ –∫–ª–µ—Ç–∫–∏
			cell_pos.z + 0.5  -- –í—ã—à–µ –∫–ª–µ—Ç–∫–∏ –¥–ª—è –≤–∏–¥–∏–º–æ—Å—Ç–∏
		)
		
		local icon_id = factory.create("#generator_icon_factory", icon_pos)
		self.generator_icons[token_key] = icon_id
		
		-- –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º –∞–Ω–∏–º–∞—Ü–∏—é –¥–ª—è —ç—Ç–æ–π –∏–∫–æ–Ω–∫–∏ —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –µ—ë –µ—â—ë –Ω–µ—Ç
		if not self.icon_animations then
			self.icon_animations = {}
		end
		if not self.icon_animations[token_key] then
			self.icon_animations[token_key] = {
				timer = 0,
				phase = 0,
				original_scale = vmath.vector3(1.0, 1.0, 1),
				animation_duration = 0.2,
				pause_duration = 5.0
			}
		end
		
		print("BOARD: Created generator icon at grid(" .. grid_x .. ", " .. grid_y .. ") pos=" .. tostring(icon_pos) .. " id=" .. tostring(icon_id))
	end
end

-- –§—É–Ω–∫—Ü–∏—è —Å–∫—Ä—ã—Ç–∏—è –∏–∫–æ–Ω–∫–∏ –≥–µ–Ω–µ—Ä–∞—Ç–æ—Ä–∞
function hide_generator_icon(self, grid_x, grid_y)
	local token_key = utils.get_token_key(grid_x, grid_y)
	if self.generator_icons[token_key] then
		go.delete(self.generator_icons[token_key])
		self.generator_icons[token_key] = nil
		
		-- –û—á–∏—â–∞–µ–º –∞–Ω–∏–º–∞—Ü–∏—é –¥–ª—è —ç—Ç–æ–π –∏–∫–æ–Ω–∫–∏
		if self.icon_animations and self.icon_animations[token_key] then
			self.icon_animations[token_key] = nil
		end
		
		print("BOARD: Removed generator icon at grid(" .. grid_x .. ", " .. grid_y .. ")")
	end
end

-- –§—É–Ω–∫—Ü–∏—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –∏–∫–æ–Ω–æ–∫ –≥–µ–Ω–µ—Ä–∞—Ç–æ—Ä–æ–≤
function update_generator_icons(self)
	-- –°–æ—Ö—Ä–∞–Ω—è–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ –∞–Ω–∏–º–∞—Ü–∏–∏ —Å—É—â–µ—Å—Ç–≤—É—é—â–∏—Ö –∏–∫–æ–Ω–æ–∫
	local saved_animations = {}
	if self.icon_animations then
		for token_key, animation in pairs(self.icon_animations) do
			saved_animations[token_key] = animation
		end
	end
	
	-- –°–Ω–∞—á–∞–ª–∞ –æ—á–∏—â–∞–µ–º –≤—Å–µ —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–µ –∏–∫–æ–Ω–∫–∏
	for token_key, icon_id in pairs(self.generator_icons) do
		if icon_id then
			go.delete(icon_id)
		end
	end
	self.generator_icons = {}
	
	-- –í–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ –∞–Ω–∏–º–∞—Ü–∏–∏
	self.icon_animations = saved_animations
	
	-- –¢–µ–ø–µ—Ä—å —Å–æ–∑–¥–∞–µ–º –∏–∫–æ–Ω–∫–∏ —Ç–æ–ª—å–∫–æ –¥–ª—è –≥–æ—Ç–æ–≤—ã—Ö –≥–µ–Ω–µ—Ä–∞—Ç–æ—Ä–æ–≤
	for token_key, token in pairs(self.tokens) do
		local generator_id = utils.create_token_string(token.evo_id, token.level)
		
		-- –ü—Ä–æ–≤–µ—Ä—è–µ–º, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ —Ñ–∏—à–∫–∞ –≥–µ–Ω–µ—Ä–∞—Ç–æ—Ä–æ–º —Å —Ä—É—á–Ω–æ–π –∞–∫—Ç–∏–≤–∞—Ü–∏–µ–π
		if generator_config.is_generator(generator_id) then
			local generator = generator_config.get_generator(generator_id)
			
			if generator and generator.manual then
				local grid_x, grid_y = utils.parse_token_key(token_key)
				if grid_x and grid_y then
					local is_reloading = is_generator_reloading(self, token_key)
					local is_dragging = self.is_dragging and self.dragged_token == token.id
					
					-- –ü—Ä–æ–≤–µ—Ä—è–µ–º –µ–º–∫–æ—Å—Ç—å –≥–µ–Ω–µ—Ä–∞—Ç–æ—Ä–∞
					local current_capacity = token.current_capacity or generator.manual.capacity
					
					-- –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –∏–∫–æ–Ω–∫—É —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –≥–µ–Ω–µ—Ä–∞—Ç–æ—Ä –≥–æ—Ç–æ–≤ –∏ –Ω–µ –ø–µ—Ä–µ—Ç–∞—Å–∫–∏–≤–∞–µ—Ç—Å—è
					if not is_reloading and not is_dragging and current_capacity and current_capacity > 0 then
						show_generator_icon(self, grid_x, grid_y)
					end
				end
			end
		end
	end
end

-- –§—É–Ω–∫—Ü–∏—è –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ —É–Ω–∏—á—Ç–æ–∂–µ–Ω–∏—è –æ–¥–Ω–æ—Ä–∞–∑–æ–≤–æ–≥–æ –≥–µ–Ω–µ—Ä–∞—Ç–æ—Ä–∞
function handle_disposable_generator_disposal(self, token_key)
    local token = self.tokens[token_key]
    if not token then return false end
    
    local generator_id = utils.create_token_string(token.evo_id, token.level)
    local generator = generator_config.get_generator(generator_id)
    if not generator then return false end
    
    -- –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω—É–∂–Ω–æ –ª–∏ —É–Ω–∏—á—Ç–æ–∂–∏—Ç—å –≥–µ–Ω–µ—Ä–∞—Ç–æ—Ä
    if not generator_config.should_dispose(generator_id) then
        return false
    end
    
    print("BOARD: Disposable generator " .. generator_id .. " has reached its limit, disposing...")
    
    -- –ü–æ–ª—É—á–∞–µ–º –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –≥–µ–Ω–µ—Ä–∞—Ç–æ—Ä–∞
    local grid_x, grid_y = utils.parse_token_key(token_key)
    if not grid_x or not grid_y then
        print("BOARD: ERROR - Could not parse token key for disposal: " .. token_key)
        return false
    end
    
    -- –£–¥–∞–ª—è–µ–º —Å—Ç–∞—Ä—É—é —Ñ–∏—à–∫—É
    if token.id and go.exists(token.id) then
        go.delete(token.id)
    end
    
    -- –£–¥–∞–ª—è–µ–º –∏–∑ —Å–ø–∏—Å–∫–∞ —Ç–æ–∫–µ–Ω–æ–≤
    self.tokens[token_key] = nil
    
    -- –û—á–∏—â–∞–µ–º –∏–∫–æ–Ω–∫–∏ –∏ –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä—ã –≥–µ–Ω–µ—Ä–∞—Ç–æ—Ä–∞
    hide_generator_icon(self, grid_x, grid_y)
    remove_generator_indicator(self, token_key)
    
    -- –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω—É–∂–Ω–æ –ª–∏ —Å–æ–∑–¥–∞—Ç—å –Ω–æ–≤—É—é —Ñ–∏—à–∫—É
    local dispose_to = generator_config.get_dispose_to(generator_id)
    if dispose_to and dispose_to ~= "" then
        -- –ü–∞—Ä—Å–∏–º dispose_to
        local dispose_evo_id, dispose_level = utils.parse_token_string(dispose_to)
        if dispose_evo_id and dispose_level then
            -- –°–æ–∑–¥–∞–µ–º –Ω–æ–≤—É—é —Ñ–∏—à–∫—É –Ω–∞ –º–µ—Å—Ç–µ —Å—Ç–∞—Ä–æ–≥–æ –≥–µ–Ω–µ—Ä–∞—Ç–æ—Ä–∞
            local new_token_key = create_token_on_board(self, dispose_evo_id, dispose_level, grid_x, grid_y)
            if new_token_key then
                print("BOARD: Replaced disposable generator " .. generator_id .. " with " .. dispose_to)
                return true
            else
                print("BOARD: ERROR - Failed to create replacement token " .. dispose_to)
            end
        else
            print("BOARD: ERROR - Invalid dispose_to format: " .. dispose_to)
        end
    else
        print("BOARD: Disposable generator " .. generator_id .. " removed without replacement")
    end
    
    return true
end

